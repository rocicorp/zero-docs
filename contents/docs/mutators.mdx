---
title: Mutators
description: Writing data with Zero
---

## Introduction

A Zero _mutator_ is basically just a TypeScript function that runs within a database transaction, which can read and write to the database.

Here's an example of a simple mutator:

```ts
import { defineMutator } from '@rocicorp/zero';
import { zql } from './schema.ts';
import z from "zod";

const updateIssue = defineMutator<Schema>(
  tx,
  z.object({
    id: z.string(),
    title: z.string(),
  }),
  async ({args: {id, title}}) => {
    if (title.length > 100) {
      throw new Error(`Title is too long`);
    }
    await tx.mutate.issue.update({id, title});
  },
);
```

## Architecture

A copy of each mutator exists on both the client and on your server:

<ImageLightbox
  src="/images/mutators/overview.png"
  className="invert dark:invert-0"
/>

Often the implementations will be the same, and you can just share their code. This is easy with full-stack frameworks like TanStack Start or Next.js.

But the implementations don't have to be the same, or even compute the same result. For example, the server can add extra checks to enforce permissions, or send notifications or interact with other systems.

### Server Authority

Zero is an example of a _server-authoritative_ sync engine. This means that the server mutator always takes precedence over the client mutator. The result from the client mutator is considered _speculative_ and is discarded as soon as the result from the server mutator is known. This is a very useful feature: it enables server-side validation, permissions, and other server-specific logic.

Imagine that you wanted to use an LLM to detect whether an issue update is spammy, rather than a simple length check. We can just add that to our server mutator:

```ts
const updateIssue = defineMutator<Schema>(
  tx,
  z.object({
    id: z.string(),
    title: z.string(),
  }),
  async ({args: {id, title}}) => {
    const response = await llamaSession.prompt(
      `Is this title update likely spam?\n\n${title}\n\nResponse "yes" or "no"`,
    );
    if (/yes/i.test(response)) {
      throw new Error(`Title is likely spam`);
    }

    // delegate rest of implementation to client mutator
    await updateIssue(tx, {id, title});
  },
);
```

If the server detects that the mutation is spammy, the client will see the error message and the mutation will be rolled back. If the server mutator succeeds, the client mutator will be rolled back and the server result will be applied.

### Life of a Mutation

When a mutator is invoked, it initially runs on the client, against the client-side datastore. Any changes are immediately applied to open queries and the user sees the changes.

In the background, Zero sends a _mutation_ (a record of the mutator having run with certain arguments) to your server's push endpoint. Your push endpoint runs the [push protocol](#custom-push-implementation), executing the server-side mutator in a transaction against your database and recording the fact that the mutation ran. The `@rocicorp/zero` package contains utilities to make it easy to implement this endpoint in TypeScript.

The changes to the database are then replicated to `zero-cache` using logical replication. `zero-cache` calculates the updates to active queries and sends rows that have changed to each client. It also sends information about the mutations that have been applied to the database.

Clients receive row updates and apply them to their local cache. Any pending mutations which have been applied to the server have their local effects rolled back. Client-side queries are updated and the user sees the changes.

## Parameters

The first argument to `defineQuery` is a *validator* that determines the query's parameters. We use [Zod](https://zod.dev/) in these examples, but you can use any validation library that implements [Standard Schema](https://standardschema.dev/).

Parameter validation is needed because mutators run on both the client and [on your server](#server-setup). In the server case, the parameters come from the client and are untrusted. These inputs are validated using the validator you provide.

Zero supports only one formal parameter for each mutator, but it can be of any type you want. The convention is to use an object with named fields for extensibility.

## CRUD API

With a mutator, Zero provides a CRUD-style API to insert, update, and delete rows. Access the API with `tx.mutate.<tablename>`:

```tsx
const myMutator = defineMutator<Schema>(
  tx,
  z.undefined(),
  async (tx) => {
    await tx.mutate.issue.create({
      // ...
    })
  },
);
```

### Insert

Create new records with `insert`:

```tsx
tx.mutate.user.insert({
  id: nanoid(),
  username: 'sam',
  language: 'js',
});
```

Optional fields can be set to `null` to explicitly set the new field to `null`. They can also be set to `undefined` to take the default value (which is often `null` but can also be some generated value server-side):

```tsx
// schema.ts
import {createTableSchema} from '@rocicorp/zero';

const userSchema = createTableSchema({
  tableName: 'user',
  columns: {
    id: {type: 'string'},
    name: {type: 'string'},
    language: {type: 'string', optional: true},
  },
  primaryKey: ['id'],
  relationships: {},
});

// app.tsx

// Sets language to `null` specifically
tx.mutate.user.insert({
  id: nanoid(),
  username: 'sam',
  language: null,
});

// Sets language to the default server-side value. Could be null, or some
// generated or constant default value too.
tx.mutate.user.insert({
  id: nanoid(),
  username: 'sam',
});

// Same as above
tx.mutate.user.insert({
  id: nanoid(),
  username: 'sam',
  language: undefined,
});
```

### Upsert

Create new records or update existing ones with `upsert`:

```tsx
tx.mutate.user.upsert({
  id: samID,
  username: 'sam',
  language: 'ts',
});
```

`upsert` supports the same `null` / `undefined` semantics for optional fields that `insert` does (see above).

### Update

Update an existing record. Does nothing if the specified record (by PK) does not exist.

You can pass a partial, leaving fields out that you don‚Äôt want to change. For example here we leave the username the same:

```tsx
// Leaves username field to previous value.
tx.mutate.user.update({
  id: samID,
  language: 'golang',
});

// Same as above
tx.mutate.user.update({
  id: samID,
  username: undefined,
  language: 'haskell',
});

// Reset language field to `null`
tx.mutate.user.update({
  id: samID,
  language: null,
});
```

### Delete

Delete an existing record. Does nothing if specified record does not exist.

```tsx
tx.mutate.user.delete({
  id: samID,
});
```

## Context

Mutator parameters are supplied by the client application and passed to the server automatically by Zero. This makes them unsuitable for authentication data, since the user could modify them.

For this reason, mutators also support a `context` parameter. When used [on the server](#server-setup), the context is passed to the mutator function separately and not client-controlled.

Use `defineMutatorWithContext` to define a mutator that takes a context parameter:

```ts
type MyZeroContext = {
  userID: string;
};

const createIssue = defineMutatorWithContext<MyZeroContext>()(
  tx,
  z.object({
    id: z.string(),
    title: z.string(),
    priority: z.number(),
  }),
  async ({
    context: {userID},
    args: {id, title, priority}
  }) => {
    // Note: User cannot control context.userID, so this
    // enforces authorship of created issue.
    await tx.mutate.issue.insert({
      id,
      title,
      priority,
      authorID: userID,
    });
  },
);
```

## mutators.ts

By convention, mutators are listed in a central `mutators.ts` file. This allows them to be easily used on both the client and server:

```ts
import { defineQuery } from '@rocicorp/zero';
import { Schema, zql } from './schema.ts';
import z from "zod";

export const queries = {
  posts: {
    create: defineMutatorWithContext<MyZeroContext>()(
      z.object({
        id: z.string(),
        title: z.string(),
        priority: z.number(),
      }),
      async (
        tx: Transaction<Schema>,
        {context: {userID}, args: {id, title, priority}}
      ) => {
        await tx.mutate.post.insert({
          id,
          title,
          priority,
          authorID: userID,
        });
      },
    ),
    update: defineMutatorWithContext<MyZeroContext>()(
      z.object({
        id: z.string(),
        title: z.string().optional(),
        priority: z.number().optional(),
      }),
      async (tx: Transaction<Schema>, {context: {userID}, args: {id, title, priority}}) => {
        const prev = await tx.query.post.where('id', id).one();
        if (!prev) {
          throw new Error(`Post not found`);
        }
        if (prev.authorID !== userID) {
          throw new Error(`Access denied`);
        }
        await tx.mutate.post.update({id, title, priority, authorID: userID});
      },
    ),
  } as const;
};
```

You can use as many levels of nesting as you want to organize your queries. And as your application grows, you can move queries to different files to keep them organized:

```ts
// zero/mutators.ts
import {postMutators} from 'zero/mutators/posts.ts';
import {userMutators} from 'zero/mutators/users.ts';

export const mutators = {
  posts: postMutators,
  users: userMutators,
}
```

## Registration

Before you can use your mutators, you need to register them with Zero.

In React or SolidJS, you'll do this by passing the `mutators` object to the `ZeroProvider` component:

```tsx
import { ZeroProvider } from '@rocicorp/zero/react';
import { mutators } from 'zero/mutators.ts';

<ZeroProvider mutators={mutators}>
  <App />
</ZeroProvider>
```

If you use the `Zero` class directly, you can pass the `mutators` object to the `Zero` constructor:

```ts
import { Zero } from '@rocicorp/zero';
import { mutators } from 'zero/mutators.ts';

const zero = new Zero({
  mutators,
});
```

### Read Data on the Client

You can read data within a client mutator using [ZQL](./reading-data):

```ts
export function createMutators() {
  return {
    issue: {
      update: async (
        tx: Transaction<Schema>,
        {id, title}: {id: string; title: string}
      ) => {
        // Read existing issue
        const prev = await tx.query.issue.where('id', id).one();

        // Validate title length. Legacy issues are exempt.
        if (!prev.isLegacy && title.length > 100) {
          throw new Error(`Title is too long`);
        }

        await tx.mutate.issue.update({id, title});
      },
    },
  } as const;
}
```

You have the full power of ZQL at your disposal, including relationships, filters, ordering, and limits.

Reads and writes within a mutator are transactional, meaning that the datastore is guaranteed to not change while your mutator is running. And if the mutator throws, the entire mutation is rolled back.

<Note type="note" heading="Run in Custom Mutators">
Outside of mutators, the `run()` method has a [`type` parameter](reading-data#running-queries-once) that can be used to wait for server results.

This parameter isn't supported within mutators, because waiting for server results makes no sense in an optimistic mutation ‚Äì it defeats the purpose of running optimistically to begin with.

When a mutator runs on the client (`tx.location === "client"`), ZQL reads only return data already cached on the client. When mutators run on the server (`tx.location === "server"`), ZQL reads always return all data.

You can use `run()` within custom mutators, but the `type` argument does nothing. In the future, passing `type` in this situation will throw an error.

</Note>

### Invoking Client Mutators

Once you have registered your client mutators, you can call them from your client-side application:

```ts
zero.mutate.issue.update({
  id: 'issue-123',
  title: 'New title',
});
```

The result of a call to a mutator is a `Promise`. You do not usually need to `await` this promise as Zero mutators run very fast, usually completing in a tiny fraction of one frame.

However because mutators occasionally need to access browser storage, they are technically `async`. Reading a row that was written by a mutator immediately after it is written may not return the new data, because the mutator may not have completed writing to storage yet.

### Waiting for Mutator Result

We typically recommend that you "fire and forget" mutators.

Optimistic mutations make sense when the common case is that a mutation succeeds. If a mutation frequently fails, then showing the user an optimistic result doesn't make sense, because it will likely be wrong.

That said there are cases where it is useful to know when a write succeeded on either the client or server.

One example is if you need to read a row directly after writing it. Zero's local writes are very fast (almost always < 1 frame), but because Zero is backed by IndexedDB, writes are still _technically_ asynchronous and reads directly after a write may not return the new data.

You can use the `.client` promise in this case to wait for a write to complete on the client side:

```ts
try {
  const write = zero.mutate.issue.insert({
    id: 'issue-123',
    title: 'New title',
  });

  // issue-123 not guaranteed to be present here. read1 may be undefined.
  const read1 = await zero.query.issue.where('id', 'issue-123').one();

  // Await client write ‚Äì almost always less than 1 frame, and same
  // macrotask, so no browser paint will occur here.
  await write.client;

  // issue-123 definitely can be read now.
  const read2 = await zero.query.issue.where('id', 'issue-123').one();
} catch (e) {
  console.error('Mutator failed on client', e);
}
```

You can also wait for the server write to succeed:

```ts
try {
  const write = zero.mutate.issue.insert({
    id: 'issue-123',
    title: 'New title',
  });

  await write.client;

  // optimistic write guaranteed to be present here, but not
  // server write.
  const read1 = await zero.query.issue.where('id', 'issue-123').one();

  // Await server write ‚Äì this involves a round-trip.
  await write.server;

  // issue-123 is written to server and any results are
  // synced to this client.
  // read2 could potentially be undefined here, for example if the
  // server mutator rejected the write.
  const read2 = await zero.query.issue.where('id', 'issue-123').one();
} catch (e) {
  console.error('Mutator failed on client or server', e);
}
```

If the client-side mutator fails, the `.server` promise is also rejected with the same error. You don't have to listen to both promises, the server promise covers both cases.

<Note heading="Returning data from mutators" slug="returning-data">
  There is not yet a way to return data from mutators in the success case ‚Äì the type of `.client` and `.server` is always `Promise<void>`. [Let us know](https://discord.rocicorp.dev/) if you need this.
</Note>

### Setting Up the Server

You will need a server somewhere you can run an endpoint on. This is typically a serverless function on a platform like Vercel or AWS but can really be anything.

Configure the push endpoint with the `ZERO_MUTATE_URL` configuration parameter:

```bash
ZERO_MUTATE_URL=https://my-server.com/api/mutate
```

The push endpoint receives a `PushRequest` as input describing one or more mutations to apply to the backend, and must return a `PushResponse` describing the results of those mutations.

If you are implementing your server in TypeScript, you can use the `PushProcessor` class to trivially implement this endpoint. Here‚Äôs an example in a [Hono](https://hono.dev/) app:

```ts
import {Hono} from 'hono';
import {handle} from 'hono/vercel';
import {Pool} from 'pg';
import {PushProcessor} from '@rocicorp/zero/server';
import {zeroNodePg} from '@rocicorp/zero/server/adapters/pg';
import {schema} from '../shared/schema';
import {createMutators} from '../shared/mutators';

const pool = new Pool({
  connectionString: process.env.ZERO_UPSTREAM_DB! as string,
});

// PushProcessor is provided by Zero to encapsulate a standard
// implementation of the push protocol.
const processor = new PushProcessor(
  zeroNodePg(schema, pool)
);

export const app = new Hono().basePath('/api');

app.post('/push', async c => {
  const result = await processor.process(
    createMutators(), c.req.raw);
  return await c.json(result);
});

export default handle(app);
```

`PushProcessor` depends on an abstract `Database`. This allows it to implement the push algorithm against any database. In this example, we use the [`pg` library](https://www.npmjs.com/package/pg) to connect to Postgres.

<Note heading="Using a different bindings library">
Zero includes several built-in database adapters. You can also easily create your own. See [ZQL on the Server](zql-on-the-server) for more information.
</Note>

To reuse the client mutators exactly as-is on the server just pass the result of the same `createMutators` function to `PushProcessor`.

### Custom Mutate URL

By default, custom mutators use the URL specified in the `ZERO_MUTATE_URL` parameter. However you can customize this on a per-client basis. To do so, list multiple comma-separted URLs in the `ZERO_MUTATE_URL` parameter:

```bash
ZERO_MUTATE_URL='https://api.example.com/mutate,https://api.staging.example.com/mutate'
```

Then choose one of those URLs by passing it to `mutateURL` on the `Zero` constructor:

```ts
const zero = new Zero({
  schema,
  mutators: createMutators(),
  mutateURL: 'https://api.staging.example.com/mutate',
});
```

### Mutate URL Patterns

The strings listed in `ZERO_MUTATE_URL` can also be [`URLPatterns`](https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API):

```bash
ZERO_MUTATE_URL="https://mybranch-*.preview.myapp.com/push"
```

This mutate URL will allow clients to choose URLs like:
- `https://mybranch-aaa.preview.myapp.com/push` ‚úÖ
- `https://mybranch-bbb.preview.myapp.com/push` ‚úÖ

But rejects URLs like:
- `https://preview.myapp.com/push` ‚ùå (missing subdomain)
- `https://malicious.com/push` ‚ùå (different domain)
- `https://mybranch-123.preview.myapp.com/push/extra` ‚ùå (extra path)
- `https://mybranch-123.preview.myapp.com/other` ‚ùå (different path)

<Note emoji="ü•á" heading="Pro Tip (tm)">
Because URLPattern is a web standard, you can test them right in your browser:
  <img alt="URL Pattern"
    src="/images/mutators/url-pattern.png"/>
</Note>

For more information, see the [URLPattern docs](https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API).

### Server Error Handling

The `PushProcessor` in `@rocicorp/zero/pg` skips any mutations that throw:

```ts
app.post('/push', async c => {
  const result = await processor.process({
    issue: {
      update: async (tx: Transaction<Schema>, data: string) => {
        // The mutation is skipped and the next mutation runs as normal.
        throw new Error('bonk');
      },
    },
  }, ...);
  return await c.json(result);
})
```

`PushProcessor` catches such errors and turns them into a structured response that gets sent back to the client. You can [recover the errors](#waiting-for-mutator-result) and show UI if you want.

It is also of course possible for the entire push endpoint to return an HTTP error, or to not reply at all:

```ts
app.post('/push', async c => {
  // This will cause the client to resend all queued mutations.
  throw new Error('zonk');
  const result = await processor.process({
    // ...
  }, ...);
  return await c.json(result);
})
```

If Zero receives any response from the push endpoint other than HTTP 200, 401, or 403, it will disconnect, wait a few moments, reconnect, and then retry all unprocessed mutations.

If Zero receives HTTP 401 or 403, the client [refreshes the `auth` token](./auth#refresh) if possible, then retries all queued mutations.

If you want a different behavior, it is possible to [implement your own](#custom-push-implementation) `PushProcessor` and handle errors differently.

### Server-Specific Code

To implement server-specific code, just run different mutators in your push endpoint!

An approach we like is to create a separate `server-mutators.ts` file that wraps the client mutators:

```ts
// server-mutators.ts
import {CustomMutatorDefs} from '@rocicorp/zero';
import {schema} from './schema';

export function createMutators(
  clientMutators: CustomMutatorDefs,
) {
  return {
    // Reuse all client mutators except the ones in `issue`
    ...clientMutators,

    issue: {
      // Reuse all issue mutators except `update`
      ...clientMutators.issue,

      update: async (
        tx: Transaction<Schema>,
        {id, title}: {id: string; title: string}
      ) => {
        // Call the shared mutator first
        await clientMutators.issue.update(tx, {id, title});

        // Record a history of this operation happening in an audit
        // log table.
        await tx.mutate.auditLog.insert({
          // Assuming you have an audit log table with fields for
          // `issueId`, `action`, and `timestamp`.
          issueId: id,
          action: 'update-title',
          timestamp: new Date().toISOString(),
        });
      },
    },
  } as const;
}
```

For simple things, we also expose a `location` field on the transaction object that you can use to branch your code:

```ts
myMutator: (tx: Transaction<Schema>) => {
  if (tx.location === 'client') {
    // Client-side code
  } else {
    // Server-side code
  }
},
```

### Permissions

Because custom mutators are just arbitrary TypeScript functions, there is no need for a special permissions system. Therefore, you won't use Zero's [write permissions](./permissions) when you use custom mutators.

In order to do permission checks, you'll need to know what user is making the request. You can pass this information to your mutators by adding a `AuthData` parameter to the `createMutators` function:

```ts
type AuthData = {
  sub: string;
};

export function createMutators(authData: AuthData | undefined) {
  return {
    issue: {
      launchMissiles: async (
        tx: Transaction<Schema>,
        args: {target: string}
      ) => {
        if (!authData) {
          throw new Error('Users must be logged in to launch missiles');
        }

        const hasPermission = await tx.query.user
          .where('id', authData.sub)
          .whereExists('permissions', q => q.where('name', 'launch-missiles'))
          .one();
        if (!hasPermission) {
          throw new Error('User does not have permission to launch missiles');
        }
      },
    },
  } as const;
}
```

The `AuthData` parameter can be any data required for authorization, but is typically just the decoded JWT:

```ts
// app.tsx
const zero = new Zero({
  schema,
  auth: encodedJWT,
  mutators: createMutators(decodedJWT),
});

// hono-server.ts
const processor = new PushProcessor(
  schema,
  connectionProvider(postgres(process.env.ZERO_UPSTREAM_DB as string)),
);
processor.process(
  createMutators(decodedJWT),
  c.req.query(),
  await c.req.json(),
);
```

### Dropping Down to Raw SQL

The `ServerTransaction` interface has a `dbTransaction` property that exposes the underlying database connection. This allows you to run raw SQL queries directly against the database.

This is useful for complex queries, or for using Postgres features that Zero doesn't support yet:

```ts
markAllAsRead: async(tx: Transaction<Schema>, {userId: string}) {
  // shared stuff ...

  if (tx.location === 'server') {
    // `tx` is now narrowed to `ServerTransaction`.
    // Do special server-only stuff with raw SQL.
    await tx.dbTransaction.query(
      `
      UPDATE notification
      SET read = true
      WHERE user_id = $1
    `,
      [userId],
    );
  }
}
```

You can use `ServerTransaction` to provide types for the underlying database transaction:

```ts
// server-mutators.ts
import type {CustomMutatorDefs, ServerTransaction} from '@rocicorp/zero';
import type {TransactionSql} from 'postgres';
import {Schema} from './schema';

type MutatorTx = ServerTransaction<Schema, TransactionSql>;

export function createMutators(clientMutators: CustomMutatorDefs) {
  return {
    // Reuse all client mutators except the ones in `issue`
    ...clientMutators,

    issue: {
      // Reuse all issue mutators except `markAllAsRead`
      ...clientMutators.issue,

      markAllAsRead: async (
        tx: MutatorTx,
        {userId}: {userId: string}
      ) => {
        await tx.dbTransaction.wrappedTransaction.unsafe(
          `
          UPDATE notification
          SET read = true
          WHERE user_id = $1
        `,
          [userId],
        );
      },
    }
  } as const;
}

```

### Notifications and Async Work

It is bad practice to hold open database transactions while talking over the network, for example to send notifications. Instead, you should let the db transaction commit and do the work asynchronously.

There is no specific support for this in custom mutators, but since mutators are just code, it‚Äôs easy to do:

```ts
// server-mutators.ts
export function createMutators(
  authData: AuthData,
  asyncTasks: Array<() => Promise<void>>,
) {
  return {
    issue: {
      update: async (
        tx: Transaction<Schema>,
        {id, title}: {id: string; title: string}
      ) => {
        await tx.mutate.issue.update({id, title});

        asyncTasks.push(async () => {
          await sendEmailToSubscribers(args.id);
        });
      },
    },
  } as const;
}
```

Then in your push handler:

```ts
app.post('/push', async c => {
  const asyncTasks: Array<() => Promise<void>> = [];
  const result = await processor.process(
    createMutators(authData, asyncTasks),
    c.req.query(),
    await c.req.json(),
  );

  await Promise.all(asyncTasks.map(task => task()));
  return await c.json(result);
});
```

### Custom Push Implementation

You can manually implement the push protocol in any programming language.

This will be documented in the future, but you can refer to the [PushProcessor](https://github.com/rocicorp/mono/blob/1a3741fbdad6dbdd56aa1f48cc2cc83938a61b16/packages/zero-pg/src/web.ts#L33) source code for an example for now.

## Disabling CRUD Mutators

Ready to go all-in on custom mutator?

Set the `enableLegacyMutators` flag to `false` in your Zero schema:

```ts
export const schema = createSchema({
  // ...
  enableLegacyMutators: false,
});
```

The `schema` object itself has the same field. So if you use a generator like `drizzle-zero`, you can just add the flag yourself:

```ts
import { Schema as ZeroSchema } from '@rocicorp/zero';
import {schema as genSchema} from './schema.gen';

export const schema = {
  ...genSchema,
  enableLegacyMutators: false,
} as const satisfies ZeroSchema;
```

This stops the CRUD mutators from showing up in `z.mutate.*`.

## Examples

- Zbugs uses [custom mutators](https://github.com/rocicorp/mono/blob/a76c9a61670cc09e1a9fe7ab795749f3eef25577/apps/zbugs/shared/mutators.ts) for all mutations, [write permissions](https://github.com/rocicorp/mono/blob/a76c9a61670cc09e1a9fe7ab795749f3eef25577/apps/zbugs/shared/mutators.ts#L61), and [notifications](https://github.com/rocicorp/mono/blob/a76c9a61670cc09e1a9fe7ab795749f3eef25577/apps/zbugs/server/server-mutators.ts#L35).
- [`hello-zero-solid`](./samples#hello-zero-solid) uses custom mutators for all mutations and for permissions.
