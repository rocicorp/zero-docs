---
title: Install Zero
---

This guide walks you through adding Zero to any TypeScript-based web app.

It should take about 10-15 minutes to complete. When you're done, you'll have Zero up and running and understand the core ideas of using Zero.

## Integrate Zero

### Set Up Your Database

You'll need a local Postgres database for development. If you don't have a preferred method, we recommend using [Docker](https://www.docker.com/):

```bash
docker run -d --name zero-postgres \
  -e POSTGRES_PASSWORD="password" \
  -p 5432:5432 \
  postgres:16-alpine \
  # IMPORTANT: logical WAL level is required for Zero
  # to sync data to its SQLite replica
  postgres -c wal_level=logical
```

This will start a Postgres database running in the background.

<Note>
  See [Connecting to Postgres](/docs/connecting-to-postgres) for more details on
  what Postgres features are required for Zero to work.
</Note>

### Install and Run Zero-Cache

Add Zero to your project:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
npm install @rocicorp/zero
```

```bash
pnpm add @rocicorp/zero

# Note: pnpm disables postinstall scripts by default for security.
# Either approve the build:
pnpm approve-builds

# Or add to package.json:
# "pnpm": {
#   "onlyBuiltDependencies": ["@rocicorp/zero-sqlite3"]
# }
```

```bash
bun add @rocicorp/zero

# Note: Bun disables postinstall scripts by default for security.
# Add to package.json:
# "trustedDependencies": ["@rocicorp/zero-sqlite3"]
```

```bash
yarn add @rocicorp/zero
```

</CodeGroup>

Start the development `zero-cache` by running the following command:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
npx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
pnpm exec zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
bunx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
yarn zero-cache-dev
```

</CodeGroup>

Zero works by continuously replicating your upstream database into a SQLite _replica_.

Zero-cache runs client queries against the replica. If there are tables or columns that will **not** be queried by Zero clients ever, you can exclude them.

You can use the [`zero-sqlite3`](/docs/debug/replication#inspecting) tool to explore `zero.db`. Try it out by connecting to Postgres and the Zero replica in two different terminals.
If you change something in Postgres, you'll see it immediately show up in the replica:

<Video
  src="/video/onboarding/zero-cache-sync.mp4"
  alt="Zero cache syncing between Postgres and SQLite"
  animation
/>

### Set Up Your Zero Schema

Zero uses information about your database schema to provide a type-safe query API in a shared `schema.ts` file.
If you use Drizzle or Prisma, you can generate your schema automatically. Otherwise, you can create the file manually.

<CodeGroup
  labels={[
    {
      text: 'Drizzle',
      sync: {orm: 'drizzle', pgClient: 'drizzle'},
    },
    {
      text: 'Prisma',
      sync: {orm: 'prisma', pgClient: 'prisma'},
    },
    {
      text: "Manual",
      sync: {orm: 'other', pgClient: 'other'},
    },
  ]}
>

<SyncedCode syncKey="pm" syncValues={['npm', 'pnpm', 'bun', 'yarn']}>

```bash
npm install -D drizzle-zero
npx drizzle-zero generate
```

```bash
pnpm add -D drizzle-zero
pnpm dlx drizzle-zero generate
```

```bash
bun add -D drizzle-zero
bunx drizzle-zero generate
```

```bash
yarn add -D drizzle-zero
yarn dlx drizzle-zero generate
```

</SyncedCode>

<SyncedCode syncKey="pm" syncValues={['npm', 'pnpm', 'bun', 'yarn']}>

```bash
npm install -D prisma-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-zero"
# }
npx prisma generate
```

```bash
pnpm add -D prisma-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-zero"
# }
pnpx prisma generate
```

```bash
bun add -D prisma-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-zero"
# }
bunx prisma generate
```

```bash
yarn add -D prisma-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-zero"
# }
yarn prisma generate
```

</SyncedCode>

```ts
// shared/schema.ts
import {table, string, createSchema} from '@rocicorp/zero';

const user = table('user')
  .columns({
    id: string(),
    name: string(),
    // ... other columns ...
  })
  .primaryKey('id');

export const schema = createSchema({
  tables: [user],
});

// Register the schema for type safety
declare module '@rocicorp/zero' {
  interface Types {
    schema: typeof schema;
  }
}
```

</CodeGroup>

<Note heading="Having trouble using your own schema?">
  Zero has some restrictions on the [Postgres features it
  supports](/docs/postgres-support). You can continue this tutorial with [a
  sample schema and seed data](https://github.com/rocicorp/onboarding) to
  evaluate it.
</Note>

{/* TODO some language about schema incompatibility? */}
{/* TODO some language about sample data? psql? */}

{/* TODO some setup for module augmentation? less verbose types?? forking prisma generator?? */}

### Set Up the Zero Client

Zero has first-class support for React and SolidJS, and community support for Svelte and Vue.

There is also a low-level API you can use in any TypeScript-based project.

{/* TODO add some preamble for "BYOA" (Bring Your Own Auth) or cookies or whatever */}

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/react';
import {schema} from './shared/schema.ts';

function Root() {
  return (
    <ZeroProvider cacheURL="http://localhost:4848" schema={schema}>
      <App />
    </ZeroProvider>
  );
}

// mycomponent.tsx
import {useZero} from '@rocicorp/zero/react';

function MyComponent() {
  const zero = useZero();
  console.log('clientID', zero.clientID);
}
```

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/solid';
import {schema} from './shared/schema.ts';

function Root() {
  return (
    <ZeroProvider cacheURL="http://localhost:4848" schema={schema}>
      <App />
    </ZeroProvider>
  );
}

// mycomponent.tsx
import {useZero} from '@rocicorp/zero/solid';

function MyComponent() {
  const zero = useZero();
  console.log('clientID', zero().clientID);
}
```

```tsx
// zero.ts
import {Zero} from '@rocicorp/zero';
import {schema} from './shared/schema.ts';

const zero = new Zero({
  cacheURL: 'http://localhost:4848',
  schema,
});

console.log('clientID', zero.clientID);

export {zero};
```

</CodeGroup>

## Sync Data

### Define Query

Alright, let's sync some data!

In Zero, we do this with _queries_. Queries can be defined anywhere, but are conventionally found in a shared `queries.ts` file.

{/* Add something like "obviously adapt this to your own schema" */}

```tsx
// shared/queries.ts
import {defineQueries, defineQuery} from '@rocicorp/zero';
import {z} from 'zod';
import {zql} from './schema.ts';

export const queries = defineQueries({
  albums: {
    byArtist: defineQuery(
      z.object({artistID: z.string()}),
      ({args: {artistID}}) => {
        return zql.album.where('artistID', artistID);
      },
    ),
  },
});

// Register the queries for type safety
declare module '@rocicorp/zero' {
  interface Types {
    queries: typeof queries;
  }
}
```

A Zero _query_ is a function that returns ZQL (Zero Query Language) which describes the data to retrieve. You can think of a query like a stored procedure in other databases.

The arguments for a query are defined by a _validator_. Any library that implements [Standard Schema](https://standardschema.dev/) is supported, such as Zod, Valibot, Effect Schema, etc.

<Note heading="Why do we need validators?">
  Queries and mutators run on your API server, where you can't trust the
  client-provided inputs.
</Note>

Use `zql` from `schema.ts` to construct and return a ZQL query. ZQL is quite powerful and allows you to build
queries with filters, sorts, relationships, and more. See the [ZQL Reference](/docs/zql) for complete details.

```bash
TODO(0xcadams): add animation showing the zql autocompletion (pending a canary for the defineQuery changes)
```

### Invoke Query

Querying for data is framework-specific. Most of the time, you will use a helper like `useQuery` that integrates into your framework's rendering model:

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// mycomponent.tsx
import {useQuery} from '@rocicorp/zero/react';
import {queries} from './shared/queries.ts';

function MyComponent() {
  const [albums] = useQuery(queries.albums.byArtist({artistID: 'artist_1'}));
  return albums.map(a => <div key={a.id}>{a.title}</div>);
}
```

```tsx
// mycomponent.tsx
import {useQuery} from '@rocicorp/zero/solid';
import {queries} from './shared/queries.ts';

function MyComponent() {
  const [albums] = useQuery(() =>
    queries.albums.byArtist({artistID: 'artist_1'}),
  );
  return albums().map(a => <div key={a.id}>{a.title}</div>);
}
```

```tsx
// albums.ts
import {zero} from './zero.ts';
import {queries} from './shared/queries.ts';

const albums = await zero.run(queries.albums.byArtist({artistID: 'artist_1'}));
console.log('albums', albums);
```

</CodeGroup>

If you run your app now, you should see an error like:

```ts
Uncaught exception. Could not get ZQL for query `albums.byArtist` because no queries endpoint is specified.
```

Let's fix that.

### Implement Query Backend

Zero doesn't allow clients to run any arbitrary ZQL against zero-cache, for both security and performance.

Instead, Zero sends the name and arguments of the query to a _queries endpoint_ on your server.

Your server returns its own implementation of the requested query and calls it, returning the ZQL expression to zero-cache.

The queries endpoint can return the exact same ZQL that ran on the client, or it could be different â€“ it commonly includes additional clauses that enforce permissions.

<CodeGroup
  labels={[
    {
      text: 'Tanstack Start',
      sync: {api: 'tanstack'},
    },
    {
      text: 'Next.js',
      sync: {api: 'nextjs'},
    },
    {
      text: 'Solid Start',
      sync: {api: 'solid'},
    },
    {
      text: 'Hono',
      sync: {api: 'hono'},
    },
  ]}
>

```ts
// src/routes/api/queries.ts
import {createFileRoute} from '@tanstack/react-router';
import {json} from '@tanstack/react-start';
import {handleQueryRequest} from '@rocicorp/zero/server';
import {queries} from '../../shared/queries.ts';

export const Route = createFileRoute('/api/queries')({
  server: {
    handlers: {
      POST: async ({request}) => {
        const result = await handleQueryRequest(request, (name, args) => {
          const q = queries.get(name);
          return q(args);
        });

        return json(result);
      },
    },
  },
});
```

```ts
// app/api/queries/route.ts
import {handleQueryRequest} from '@rocicorp/zero/server';
import {queries} from '../../shared/queries.ts';

export async function POST(req: Request) {
  const result = await handleQueryRequest(req, (name, args) => {
    const q = queries.get(name);
    return q(args);
  });

  return Response.json(result);
}
```

```ts
// src/routes/api/queries.ts
import type {APIEvent} from '@solidjs/start/server';
import {handleQueryRequest} from '@rocicorp/zero/server';
import {queries} from '../../shared/queries.ts';

export async function POST(event: APIEvent) {
  const body = await event.request.json();

  const result = await handleQueryRequest(body, (name, args) => {
    const q = queries.get(name);
    return q(args);
  });

  return new Response(JSON.stringify(result), {
    headers: {'Content-Type': 'application/json'},
  });
}
```

```ts
// api/app.ts
import {Hono} from 'hono';
import {handleQueryRequest} from '@rocicorp/zero/server';
import {queries} from '../shared/queries.ts';

const app = new Hono();

app.post('/api/queries', async c => {
  const result = await handleQueryRequest(c.req, (name, args) => {
    const q = queries.get(name);
    return q(args);
  });

  return c.json(result);
});
```

</CodeGroup>

Stop and re-run zero-cache with the URL of the queries endpoint:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERIES_URL="http://localhost:3000/api/queries"
npx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERIES_URL="http://localhost:3000/api/queries"
pnpm exec zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERIES_URL="http://localhost:3000/api/queries"
bunx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERIES_URL="http://localhost:3000/api/queries"
yarn zero-cache-dev
```

</CodeGroup>

If you reload the page, you will see data!
Zero queries update live, so if you edit data in Postgres directly, you will see it update in the Zero replica AND the UI:

<Video
  src="/video/onboarding/zero-cache-ui-sync.mp4"
  alt="Zero cache syncing between Postgres and SQLite and UI"
  animation
/>

### More about Queries

You now know the basics, but there are a few more important pieces you'll need to learn for your first real app:

- How authentication and permissions work.
- Preloading queries to create instantly responsive UI.

For these details and more, see Reading Data with Queries.

But for now, let's move on to writes!

## Mutate Data

### Define Mutators

Data is written in Zero apps using _mutators_.
Similar to queries, we use a shared `mutators.ts` file:

```tsx
// shared/mutators.ts
import {defineMutators, defineMutator} from '@rocicorp/zero';
import {zql} from './schema.ts';
import {z} from 'zod';

export const mutators = defineMutators({
  albums: {
    create: defineMutator(
      z.object({
        id: z.string(),
        artistID: z.string(),
        title: z.string(),
        year: z.number(),
      }),
      async ({tx, args: {id, artistID, title, year}}) => {
        await tx.mutate.album.insert({id, artistID, title, year});
      },
    ),
  },
});

// Register the mutators for type safety
declare module '@rocicorp/zero' {
  interface Types {
    mutators: typeof mutators;
  }
}
```

You can use the [CRUD-style API](/docs/mutators#writing-data) on `tx` to write data within your mutator.
You can also use `tx.run(q)` to run queries or ZQL expressions.

<Note type="warning" heading="Always await operations in mutators">
  Mutators almost always run in the same frame on the client, against local
  data. The reason mutators are marked `async` is because on the server, reading
  from the `tx` object goes over the network to Postgres. Also, in edge cases on
  the client, `tx.get()` can go to local storage (IndexedDB or SQLite).
</Note>

Unlike queries, you _must_ register your mutators with Zero before you can use them:

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/react';
import {mutators} from './shared/mutators.ts';
import {schema} from './shared/schema.ts';

function Root() {
  return (
    <ZeroProvider
      cacheURL="http://localhost:4848"
      schema={schema}
      mutators={mutators}
    >
      <App />
    </ZeroProvider>
  );
}
```

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/solid';
import {mutators} from './shared/mutators.ts';
import {schema} from './shared/schema.ts';

function Root() {
  return (
    <ZeroProvider
      cacheURL="http://localhost:4848"
      schema={schema}
      mutators={mutators}
    >
      <App />
    </ZeroProvider>
  );
}
```

```tsx
// zero.ts
import {Zero} from '@rocicorp/zero';
import {schema} from './shared/schema.ts';
import {mutators} from './shared/mutators.ts';

const zero = new Zero({
  cacheURL: 'http://localhost:4848',
  schema,
  mutators,
});

console.log('clientID', zero.clientID);

export {zero};
```

</CodeGroup>

### Invoke Mutators

You can now call mutators via `zero.mutate`:

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// mycomponent.tsx
import {useZero} from '@rocicorp/zero/react';
import {mutators} from './shared/mutators.ts';

function MyComponent() {
  const zero = useZero();

  const onClick = async () => {
    const album = {
      id: 'album_6',
      artistID: 'artist_1',
      title: 'Please Please Me',
      year: 1963,
    };
    const result = zero.mutate(mutators.albums.create(album));
    const clientResult = await result.client;

    if (clientResult.type === 'error') {
      console.error('Failed to create album', clientResult.error.message);
    } else {
      console.log('Album created!');
    }
  };

  return <button onClick={onClick}>Create Album</button>;
}
```

```tsx
// mycomponent.tsx
import {useQuery} from '@rocicorp/zero/solid';
import {mutators} from './shared/mutators.ts';

function MyComponent() {
  const zero = useZero();

  const onClick = async () => {
    const album = {
      id: 'album_6',
      artistID: 'artist_1',
      title: 'Please Please Me',
      year: 1963,
    };
    const result = zero().mutate(mutators.albums.create(album));
    const clientResult = await result.client;

    if (clientResult.type === 'error') {
      console.error('Failed to create album', clientResult.error.message);
    } else {
      console.log('Album created!');
    }
  };

  return <button onClick={onClick}>Create Album</button>;
}
```

```tsx
// albums.ts
import {zero} from './zero.ts';
import {mutators} from './shared/mutators.ts';

const album = {
  id: 'album_6',
  artistID: 'artist_1',
  title: 'Please Please Me',
  year: 1963,
};
const result = await zero.mutate(mutators.albums.create(album));
const clientResult = await result.client;

if (clientResult.type === 'error') {
  console.error('Failed to create album', clientResult.error.message);
} else {
  console.log('Album created!');
}
```

</CodeGroup>

If you run this app now, you should be able to see the UI update optimistically, but you'll also see an error in zero-cache:

```ts
Uncaught exception. Could not execution mutation `albums.create` because no mutate endpoint is specified.
```

This is because, like queries, we need to implement an endpoint in our API. Let's fix it!

### Implement Mutate Endpoint

Zero requires a _mutate endpoint_ which runs on your server and connects directly to your Postgres database.
Zero provides helpers to implement this easily.

You can use the Zero Postgres adapters to create a `dbProvider` instance:

<CodeGroup
  labels={[
    {
      text: 'Drizzle',
      sync: {pgClient: 'drizzle'},
    },
    {
      text: 'node-postgres',
      sync: {pgClient: 'node-postgres'},
    },
    {
      text: 'postgres.js',
      sync: {pgClient: 'postgres-js'},
    },
  ]}
>

```ts
// app/api/mutate/db-provider.ts
import {zeroDrizzle} from '@rocicorp/zero/server/adapters/drizzle';
import {schema} from '../../shared/schema.ts';

// pass a drizzle client instance. for example:
// const drizzleClient = drizzle(pool, { schema: drizzleSchema })
export const dbProvider = zeroDrizzle(schema, drizzleClient);

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface Types {
    dbProvider: typeof dbProvider;
  }
}
```

```ts
// app/api/mutate/db-provider.ts
import {zeroNodePg} from '@rocicorp/zero/server/adapters/pg';
import {Pool} from 'pg';
import {schema} from '../../shared/schema.ts';

const pool = new Pool({
  connectionString: process.env.ZERO_UPSTREAM_DB!,
});
export const dbProvider = zeroNodePg(schema, pool);

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface Types {
    dbProvider: typeof dbProvider;
  }
}
```

```ts
// app/api/mutate/db-provider.ts
import {zeroPostgresJS} from '@rocicorp/zero/server/adapters/postgresjs';
import postgres from 'postgres';
import {schema} from '../../shared/schema.ts';

const sql = postgres(process.env.ZERO_UPSTREAM_DB!);
export const dbProvider = zeroPostgresJS(schema, sql);

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface Types {
    dbProvider: typeof dbProvider;
  }
}
```

</CodeGroup>

Then, you can use the `dbProvider` to handle the mutate request:

<CodeGroup
  labels={[
    {
      text: 'Tanstack Start',
      sync: {api: 'tanstack'},
    },
    {
      text: 'Next.js',
      sync: {api: 'nextjs'},
    },
    {
      text: 'Solid Start',
      sync: {api: 'solid'},
    },
    {
      text: 'Hono',
      sync: {api: 'hono'},
    },
  ]}
>

```ts
// src/routes/api/mutate.ts
import {createFileRoute} from '@tanstack/react-router';
import {json} from '@tanstack/react-start';
import {handleMutateRequest} from '@rocicorp/zero/server';
import {mutators} from '../../shared/mutators.ts';
import {dbProvider} from '../../db-provider.ts';

export const Route = createFileRoute('/api/mutate')({
  server: {
    handlers: {
      POST: async ({request}) => {
        const result = await handleMutateRequest(
          dbProvider,
          request,
          (transact, mutation) => {
            // Run any external API validation/checks before the db tx.
            // If you throw here, the mutation will be rejected.

            const result = await transact(async tx => {
              const mutator = mutators.get(mutation.name);
              return mutator(mutation.args).run(tx); // TODO(0xcadams): no context here
            });

            // Run "fire and forget" work here, like sending
            // notifications/analytics. If you throw here,
            // it will be logged but won't change the mutation result.

            return result;
          },
        );

        return json(result);
      },
    },
  },
});
```

```ts
// app/api/mutate/route.ts
import {handleMutateRequest} from '@rocicorp/zero/server';
import {mutators} from '../../shared/mutators.ts';
import {dbProvider} from '../../db-provider.ts';

export async function POST(req: Request) {
  const result = await handleMutateRequest(
    dbProvider,
    req,
    (transact, mutation) => {
      // Run any external API validation/checks before the db tx.
      // If you throw here, the mutation will be rejected.

      const result = await transact(async tx => {
        const mutator = mutators.get(mutation.name);
        return mutator(mutation.args).run(tx); // TODO(0xcadams): no context here. correct??
      });

      // Run "fire and forget" work here, like sending
      // notifications/analytics. If you throw here,
      // it will be logged but won't change the mutation result.

      return result;
    },
  );

  return Response.json(result);
}
```

```ts
// src/routes/api/mutate.ts
import type {APIEvent} from '@solidjs/start/server';
import {handleMutateRequest} from '@rocicorp/zero/server';
import {mutators} from '../../shared/mutators.ts';
import {dbProvider} from '../../db-provider.ts';

export async function POST(event: APIEvent) {
  const body = await event.request.json();

  const result = await handleMutateRequest(
    dbProvider,
    req,
    (transact, mutation) => {
      // Run any external API validation/checks before the db tx.
      // If you throw here, the mutation will be rejected.

      const result = await transact(async tx => {
        const mutator = mutators.get(mutation.name);
        return mutator(mutation.args).run(tx); // TODO(0xcadams): no context here. correct??
      });

      // Run "fire and forget" work here, like sending
      // notifications/analytics. If you throw here,
      // it will be logged but won't change the mutation result.

      return result;
    },
  );

  return new Response(JSON.stringify(result), {
    headers: {'Content-Type': 'application/json'},
  });
}
```

```ts
// api/app.ts
import {handleMutateRequest} from '@rocicorp/zero/server';
import {mutators} from '../shared/mutators.ts';
import {dbProvider} from './db-provider.ts';

app.post('/api/mutate', async c => {
  const result = await handleMutateRequest(
    dbProvider,
    c.req,
    (transact, mutation) => {
      // Run any external API validation/checks before the db tx.
      // If you throw here, the mutation will be rejected.

      const result = await transact(async tx => {
        const mutator = mutators.get(mutation.name);
        return mutator(mutation.args).run(tx); // TODO(0xcadams): no context here. correct??
      });

      // Run "fire and forget" work here, like sending
      // notifications/analytics. If you throw here,
      // it will be logged but won't change the mutation result.

      return result;
    },
  );

  return c.json(result);
});
```

</CodeGroup>

Restart zero-cache to tell it about this new endpoint:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERIES_URL="http://localhost:3000/api/queries"
export ZERO_MUTATE_URL="http://localhost:3000/api/mutate"
npx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERIES_URL="http://localhost:3000/api/queries"
export ZERO_MUTATE_URL="http://localhost:3000/api/mutate"
pnpm exec zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERIES_URL="http://localhost:3000/api/queries"
export ZERO_MUTATE_URL="http://localhost:3000/api/mutate"
bunx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERIES_URL="http://localhost:3000/api/queries"
export ZERO_MUTATE_URL="http://localhost:3000/api/mutate"
yarn zero-cache-dev
```

</CodeGroup>

If you refresh the page, your mutation should commit to the database and sync to other clients:

<Video
  src="/video/onboarding/zero-cache-multiple-clients.mp4"
  alt="Zero syncing data between multiple clients"
  animation
/>

### More about Mutators

Just as with queries, the separate server implementation of mutators extends elegantly to enable write permissions.
Zero also has built-in helpers to do work after a mutator runs on the server, like send notifications.

For these details and more, see Writing Data with Mutators.

## That's It!

Congratulations! You now know the basics for building with Zero ðŸ¤¯.

Possible next steps:

- Learn about authentication and permissions
- See some samples of built-out Zero apps
- Learn how to deploy your app to production
- Learn the big picture design of Zero
