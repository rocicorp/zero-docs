---
title: ZQL on the Server
---

The Zero package includes utilities to run ZQL on the server directly against your upstream Postgres database.

This is useful for many reasons:

- It allows [Custom Mutators](custom-mutators) to read data using ZQL to check permissions or invariants.
- You can use ZQL to implement standard REST endpoints, allowing you to share code with custom mutators.
- In the future ([but not yet implemented](#ssr)), this can support server-side rendering.

<Note type="warning" slug="schema-read">
  `ZQLDatabase` currently does a read of your postgres
  schema before every transaction. This is fine for most
  usages, but for high scale it may become a problem. [Let
  us know](https://bugs.rocicorp.dev/issue/3799) if you need
  a fix for this.
</Note>

## Creating a Database

To run ZQL on the database, you will create a `ZQLDatabase` instance. Zero ships with
several built-in factories for popular Postgres bindings libraries.

### node-postgres

The industry standard [`node-postgres`](https://node-postgres.com/) library is supported via `zeroNodePg`:

```ts
import {Pool} from 'pg'
import {zeroNodePg} from '@rocicorp/zero/server/adapters/pg'
import {schema} from '../shared/schema'

const db = zeroNodePg(
  schema,
  new Pool({
    connectionString: process.env.ZERO_UPSTREAM_DB!,
  }),
)
```

You can also pass a `Client`:

```ts
import {Client} from 'pg'
import {zeroNodePg} from '@rocicorp/zero/server/adapters/pg'
import {schema} from '../shared/schema'
const client = new Client({
  connectionString: process.env.ZERO_UPSTREAM_DB!,
})
await client.connect()
const db = zeroNodePg(schema, client)
```

### Postgres.js

The popular [`Postgres.js`](https://github.com/porsager/postgres) library is supported via `zeroPostgresJS`:

```ts
import postgres from 'postgres'
import {zeroPostgresJS} from '@rocicorp/zero/server/adapters/postgresjs'
import {schema} from '../shared/schema'

const db = zeroPostgresJS(
  schema,
  postgres(process.env.ZERO_UPSTREAM_DB!),
)
```

### Drizzle

Zero also includes an adapter for [Drizzle ORM](https://orm.drizzle.team/):

```ts
import {Pool} from 'pg'
import {drizzle} from 'drizzle-orm/node-postgres'
import {zeroDrizzle} from '@rocicorp/zero/server/adapters/drizzle'
import * as drizzleSchema from './drizzle-schema'

const drizzleDb = drizzle(pool, {schema: drizzleSchema})
const db = zeroDrizzle(schema, drizzleDb)
```

Within your custom mutators, you can access the underlying `drizzleDb` via `tx.wrappedTransaction`:

```ts
// server-mutators.ts
// Use a type helper for the server transaction type
import type {ServerTransaction} from '@rocicorp/zero/server'
import type {DrizzleTransaction} from '@rocicorp/zero/server/adapters/drizzle'

type ServerTx = ServerTransaction<
  Schema,
  DrizzleTransaction<typeof drizzleDb>
>

async function createUser(
  tx: ServerTx,
  {id, name}: {id: string; name: string},
) {
  // this is then fully typed w/ drizzle
  await tx.dbTransaction.wrappedTransaction
    .insert(drizzleSchema.user)
    .values({id, name})
}
```

### Custom Database

To implement support for some other Postgres bindings library, you will implement the `DBConnection` interface.

See the implementations for the [existing adapters](https://github.com/rocicorp/mono/tree/6c27d88ce5a052fb8e1be90d072ddd0ebc13622a/packages/zero-server/src/adapters) for examples.

## Running ZQL

Once you have an instance of `ZQLDatabase`, use the `transaction()` method to run ZQL:

```ts
await db.transaction(async tx => {
  // await tx.mutate...
  // await tx.query...
  // await myMutator(tx, ...args)
})
```

## SSR

Zero doesn't yet have the wiring setup in its bindings layers to really nicely support server-side rendering ([patches welcome though!](https://bugs.rocicorp.dev/issue/3491)).

For now, we don't recommend using Zero with SSR. Use your framework's recommended pattern to prevent SSR execution:

### Next.js

Add the `use client`
[directive](https://nextjs.org/docs/app/api-reference/directives/use-client).

### SolidStart

Wrap components that use Zero with the
[`clientOnly`](https://docs.solidjs.com/solid-start/reference/client/client-only)
higher-order component.

The standard `clientOnly` pattern uses dynamic imports, but note that this
approach (similar to [React's `lazy`](https://react.dev/reference/react/lazy))
works with any function returning a `Promise<{default: () => JSX.Element}>`. If
code splitting is unnecessary, you can skip the dynamic import.

### TanStack Start

Use [React's `lazy`](https://react.dev/reference/react/lazy) for dynamic
imports.
