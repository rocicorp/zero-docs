---
title: Add to Existing Project
---

This tutorial walks you through adding Zero to an existing web app step-by-step.

You can follow along using one of our starting templates, or adapt the instructions to your own TypeScript-based web app.

It should take about 15 minutes to complete. When you're done, you'll have the Zero sync engine integrated into your app.

## Set Up Your Database

You'll need a local Postgres database for development. If you don't have a preferred method, we recommend using [Docker](https://www.docker.com/):

```bash
docker run -d --name zero-postgres \
  -e POSTGRES_PASSWORD="password" \
  -p 5432:5432 \
  postgres:16-alpine \
  # IMPORTANT: logical WAL level is required for Zero
  # to sync data to its SQLite replica
  postgres -c wal_level=logical
```

This will start a Postgres database running in the background.

<Note heading="Supported Postgres features">
  See [Supported Postgres Features](/docs/postgres-support) for more details on
  how Zero works with Postgres.
</Note>

## Install and Run Zero-Cache

Add Zero to your project:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
npm install @rocicorp/zero
```

```bash
pnpm add @rocicorp/zero
```

```bash
bun add @rocicorp/zero
```

```bash
yarn add @rocicorp/zero
```

</CodeGroup>

Start the development `zero-cache` by running the following command:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
npx zero-cache-dev # run zero-cache in dev mode on port 4848
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
pnpm exec zero-cache-dev # run zero-cache in dev mode on port 4848
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
bunx zero-cache-dev # run zero-cache in dev mode on port 4848
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
yarn zero-cache-dev # run zero-cache in dev mode on port 4848
```

</CodeGroup>

Zero works by continuously replicating your upstream database into a SQLite _replica_.

Zero cache runs client queries against the replica. If there are tables or columns that will **not** be queried by Zero clients ever, you can exclude them.

You can use the `zero-sqlite3` tool to explore `zero.db`. Try it out by connecting to Postgres and the Zero replica in two different terminals.
If you change something in Postgres, you'll see it immediately show up in the replica:

```
video
```

## Set Up Your Zero Schema

Zero uses information about your database schema to provide a type-safe query API.
If you use Drizzle or Prisma, you can generate your schema using:

<CodeGroup
  labels={[
    {
      text: 'Drizzle',
      sync: {orm: 'drizzle'},
    },
    {
      text: 'Prisma',
      sync: {orm: 'prisma'},
    },
  ]}
>

<SyncedCode syncKey="pm" syncValues={['npm', 'pnpm', 'bun', 'yarn']}>

```bash
npx drizzle-zero generate
```

```bash
pnpm dlx drizzle-zero generate
```

```bash
bunx drizzle-zero generate
```

```bash
yarn dlx drizzle-zero generate
```

</SyncedCode>

<SyncedCode syncKey="pm" syncValues={['npm', 'pnpm', 'bun', 'yarn']}>

```bash
npm install @passionfroot/prisma-generator-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-generator-zero"
# }
npx prisma generate
```

```bash
pnpm add @passionfroot/prisma-generator-zero
# Add this to your prisma schema:
# generator zero {
#   provider       = "prisma-generator-zero"
# }
pnpx prisma generate
```

```bash
bun add @passionfroot/prisma-generator-zero
# Add this to your prisma schema:
# generator zero {
#   provider       = "prisma-generator-zero"
# }
bunx prisma generate
```

```bash
yarn add @passionfroot/prisma-generator-zero
# Add this to your prisma schema:
# generator zero {
#   provider       = "prisma-generator-zero"
# }
yarn prisma generate
```

</SyncedCode>

</CodeGroup>

If you don't use Drizzle or Prisma, you can [create a `schema.ts` file manually](/docs/zero-schema).

{/* TODO some language about schema incompatibility? */}
{/* TODO some language about sample data? psql? */}

{/* TODO some setup for module augmentation? less verbose types?? */}

## Set Up the Zero Client

Zero has first-class support for React and SolidJS, and community support for Svelte and Vue.

There is also a low-level API you can use in any TypeScript-based project.

{/* TODO add some preamble for "BYOA" (Bring Your Own Auth) or cookies or whatever */}

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {framework: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {framework: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {framework: 'typescript'},
    },
  ]}
>

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/react';
import {schema} from './generated/schema.ts';

function Root() {
  return (
    <ZeroProvider cacheURL="http://localhost:4848" schema={schema}>
      <App />
    </ZeroProvider>
  );
}

// mycomponent.tsx
import {useZero} from '@rocicorp/zero/react';

function MyComponent() {
  const zero = useZero();
  console.log('clientID', zero.clientID);
}
```

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/solid';
import {schema} from './generated/schema.ts';

function Root() {
  return (
    <ZeroProvider cacheURL="http://localhost:4848" schema={schema}>
      <App />
    </ZeroProvider>
  );
}

// mycomponent.tsx
import {useZero} from '@rocicorp/zero/solid';

function MyComponent() {
  const zero = useZero();
  console.log('clientID', zero().clientID);
}
```

```tsx
import {Zero} from '@rocicorp/zero';
import {schema} from './generated/schema.ts';

const zero = new Zero({
  cacheURL: 'http://localhost:4848',
  schema,
});
console.log('clientID', zero.clientID);
```

</CodeGroup>

## Sync Data

### Define Query

Alright, let's sync some data!

In Zero, we do this with _queries_. Queries can be defined anywhere, but are conventionally found in a shared `queries.ts` file:

```tsx
// queries.ts
import {defineQueries, defineQuery} from '@rocicorp/zero';
import {zql} from './schema.ts';
import {z} from 'zod';

export const queries = defineQueries({
  albums: {
    byArtist: defineQuery(
      z.object({artistID: z.string()}),
      ({args: {artistID}}) => {
        return zql.album.where('artistID', artistID);
      },
    ),
  },
});

// Register the queries type with Zero
declare module '@rocicorp/zero' {
  interface Register {
    queries: typeof queries;
  }
}
```

<Note>
  You can of course factor this into separate files as your app grows. The main point is that there's a central `queries` export that contains all the queries.
</Note>

A Zero _query_ is a function that takes some arguments and returns a ZQL (Zero Query Language) statement.
You can think of a query like a stored procedure in other databases.

The arguments for a query are defined by a _validator_. Any validator that implements Standard Schema is supported, such as Zod, Valibot, Effect Schema, etc.

<Note>
  Validators are needed because Zero queries run on your server too, where we can't trust the client-provided inputs.
</Note>

Use `zql` from `schema.ts` to construct and return a ZQL query. ZQL is quite powerful and allows you to build
queries with filters, sorts, relationships, and more. See the ZQL Reference for complete details.

```bash
animation
```

Once you've got some queries defined, register them with Zero:

```tsx
import {ZeroProvider} from '@rocicorp/zero';
import {schema} from './zero/schema.ts';
import {queries} from './zero/queries.ts';

function Root() {
  return (
    <ZeroProvider
      cacheURL="https://localhost:4848"
      schema={schema}
      queries={queries}
    >
      <App />
    </ZeroProvider>
  );
}
```

### Invoke Query

How to invoke your query depends on your framework. Most times you will use a helper like React's `useQuery` that integrates into your framework's reactivity system:

```tsx
import {useQuery} from "@rocicorp/react/zero";
import {Schema} from "zero/schema.ts";
import {Queries} from "zero/queries.ts";

function MyComponent() {
  const z = useZero<Schema, Queries>();
    const [users] = useQuery(z.query.albums.byArtist({artistID: '...'}));
    return users.map(u => ...);
}
```

But if you run your app now, it still doesn't quite work. You should see an error like:

```
Uncaught exception. Could not get ZQL for query `listAlbums` because no queries endpoint is specified.
```

Let's fix that.

### Implement Query Backend

Zero doesn't allow clients to sync any arbitrary ZQL from the server ‚Äì doing so would not make sense for security or performance reasons.

Instead, Zero sends only the name and args of a query to a _queries endpoint_ on your server.

Your server finds its own implementation of the requested query and invokes it, returning the resulting ZQL to zero-cache.

The queries endpoint can return the exact same ZQL that ran on the client, or it could be different ‚Äì for example it might include additional clauses that enforce permissions.

You can implement the queries endpoint yourself, but `@rocicorp/zero` provides `handleQueriesRequest` and `queryByName` to makes it very easy:

```tsx
import type {
  ReadonlyJSONValue,
  queryByName,
  withValidation,
} from '@rocicorp/zero';
import {handleQueriesRequest} from '@rocicorp/zero/server';
import {queries} from 'zero/queries.ts';

app.post('/queries', async req => {
  return Response.json(await handleQueriesRequest(queryZQL, req));
});

function queryZQL(name: string, args: ReadonlyJSONValue | undefined) {
  const query = withValidation(queryByName(queries, name));
  return query({args});
}
```

Set the URL of the queries endpoint with the `ZERO_QUERIES_URL` parameter to `zero-cache`:

```tsx
ZERO_UPSTREAM_DB=... \
ZERO_QUERIES_URL=... \
npx zero-cache-dev
```

Now if you run your app again, you will see your data:

```tsx
animation;
```

ü•≥

Zero queries update live, so if you now go back to your Postgres terminal and change some data,
you will see it update in the Zero replica AND the UI:

```tsx
animation;
```

### More about Queries

You now know the basics, but there are a few more important pieces you'll need to learn for your first real app:

- How authentication and permissions work.
- Preloading queries to create instantly responsive UI.

For these details and more, see Reading Data with Queries.

But for now, let's move on to writes!

## Mutate Data

### Define Mutators

Data is written in Zero apps using _mutators._

Just as with queries, we use a central `mutators.ts` file:

```tsx
// mutators.ts
import {defineMutators, defineMutator} from '@rocicorp/zero';
import {zql} from 'zero/schema.ts';
import {z} from 'zod';

export const mutators = defineMutators({
  albums: {
    create: defineMutator(
      z.object({
        id: z.string(),
        artistID: z.string(),
        title: z.string(),
        year: z.number(),
      }),
      async ({tx, args: {album}}) => {
        await tx.mutate.album.create(album);
      },
    ),
  },
});

// Register the mutators type with Zero
declare module '@rocicorp/zero' {
  interface Register {
    mutators: typeof mutators;
  }
}
```

Use the CRUD API on the `tx` parameter to do simple single-row read or write operations within your mutator. You can also use `tx.query` to run queries or ZQL expressions.

<aside>
‚ö†Ô∏è

Mutators almost always run instantly on the client, in the same frame. The reason mutators are marked async is because on the server,
reading from the `tx` object goes over the network to Postgres. Also, in edge cases on the client, `tx.get()` can go to local storage (IDB).

Always `await` CRUD operations within your mutator, otherwise you will see an error about operations running after a transaction has completed.

</aside>

Just as with queries, you register your mutators with Zero at startup:

```tsx
import {ZeroProvider} from '@rocicorp/zero';
import {queries} from 'zero/queries';
import {mutators} from 'zero/mutators.ts';
import {schema} from 'zero/schema.ts';

function Root() {
  return (
    <ZeroProvider
      cacheURL="http://localhost:4848"
      schema={schema}
      queries={queries}
      mutators={mutators}
    >
      <App />
    </ZeroProvider>
  );
}
```

### Invoke Mutators

Invoke mutators via `zero.mutate`:

```tsx
// mycomponent.ts
import {useZero} from '@rocicorp/zero/react';
import {Schema} from 'zero/schema.ts';
import {Queries} from 'zero/queries.ts';
import {Mutators} from 'zero/mutators.ts';

function MyComponent() {
  const zero = useZero();

  const onClick = async () => {
      const album = { ... };
      await zero.mutate.createAlbum({album});
  };

  return <button onClick={onClick}>Create Album</button>
}
```

If you run this app now, you should be able to see the UI update optimistically, but you'll also see this error in zero-cache:

```
Uncaught exception. Could not execution mutation `myComponent.createIssue` because no mutate endpoint is specified.
```

This is because again, we don't have a server implementation for this mutator. Let's fix it!

### Implement Mutate Endpoint

Just as with the queries endpoint, you can implement the mutate endpoint yourself but Zero provides some handy utilities to make it easy:

```tsx
import type {
  ReadonlyJSONValue,
  mutatorByName,
  withValidation,
} from '@rocicorp/zero';
import {handleMutateRequest, TransactFn} from '@rocicorp/zero/server';
import {mutators} from 'zero/mutators.ts';
import postgres from 'postgres';

const sql = postgres(process.env.ZERO_UPSTREAM_DB as string);
const dbProvider = zeroPostgresJS(schema, sql);

app.post('/mutate', async req => {
  return await handleMutateRequest(dbProvider, handleMutate, req);
});

async function handleMutate(transact: TransactFn, name: string) {
  // Run any external API validation/checks before the tx
  // if this throws, the mutation will be rejected

  const result = await transact(async ({tx, args}) => {
    const mutator = withValidation(mutatorByName(mutators, name));
    return await mutator({tx, args});
  });

  // Run "fire and forget" work here, like sending
  // notifications/analytics. If it throws, it will be logged
  // but won't change the mutation result.

  return result;
}
```

Now if you run your app again, your mutate should work and sync to other windows:

```
video
```

### More about Mutators

Just as with queries, the separate server implementation of mutators extends elegantly to enable write permissions.
Zero also has built-in helpers to do work after a mutator runs on the server, like send notifications.

For these details and more, see Writing Data with Mutators.

## That's It

Congratulations! You now know the basics for building with Zero ü§Ø.

Possible next steps:

- Learn about authentication and permissions
- See some samples of built-out Zero apps
- Learn how to deploy your app to production
- Learn the big picture design of Zero
