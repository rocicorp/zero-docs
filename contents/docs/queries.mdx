---
title: Queries
description: Reading and syncing data with Zero.
---

## Introduction

A Zero _query_ is basically just a typescript function that returns [ZQL](zql) describing the data to retrieve.

Here's a simple example:


```ts
import { defineQuery } from '@rocicorp/zero';
import { zql } from './schema.ts';
import z from "zod";

const myPostsQuery = defineQuery(
  z.object({ id: z.string() }),
  ({ args: { id } }) => zql.post.where('authorID', id),
);
```

## Architecture

A copy of each query exists on both the client and on your server:

<ImageLightbox
  src="/images/custom-queries/queries4.svg"
  className="invert dark:invert-0"
/>

When a query is invoked, it initially runs on the client, against the client-side datastore. Any matching data is returned immediately and the user sees instant results.

In the background, the query is also sent to zero-cache. Specifically what's sent is the name and arguments to the query, not the ZQL.

Zero-cache then calls the `queries` endpoint on your server to get the ZQL for the query. Your server looks up its implementation of the query, invokes it, and returns the resulting ZQL expression to zero-cache.

Zero-cache then runs this ZQL against the server-side data. The initial server result is sent back to the client and the client query updates in response.

If the server-side database changes, zero-cache updates the query and sends any rows changes back to the client, which again updates the client query and the user sees the changes.

## Parameters

The first argument to `defineQuery` is a *validator* that determines the query's parameters. We use [Zod](https://zod.dev/) in these examples, but you can use any validation library that implements [Standard Schema](https://standardschema.dev/).

Parameter validation is needed because Zero queries run on both the client and [on your server](#server-setup). In the server case, the parameters come from the client and are untrusted. These inputs are validated using the validator you provide.

Zero supports only one formal parameter for each query, but it can be of any type you want. The convention is to use an object with named fields for extensibility:

```ts
const searchPosts = defineQuery(
  z.object({
    title: z.string().optional(),
    authorID: z.string().optional(),
    isOpen: z.boolean().optional(),
  }),
  ({ args: { title, authorID, isOpen } }) => {
    let q = zql.post;
    if (title !== undefined) {
      q = q.where('title', title);
    }
    if (authorID !== undefined) {
      q = q.where('authorID', authorID);
    }
    if (isOpen !== undefined) {
      q = q.where('isOpen', isOpen);
    }
    return q;
  },
);
```

<Note emoji="üßë‚Äçüíª" heading="Queries are code">
Although queries must ultimately return a ZQL expression, they can use any code you want to compute that expression. It's common to use `if` statements and other control flow to build the ZQL expression based on the parameters.
</Note>

## Context

Query parameters are supplied by the client application and passed to the server automatically by Zero. This makes them unsuitable for authentication data, since the user could modify them.

For this reason, Zero queries also support a `context` parameter. When used [on the server](#server-setup), the context is passed to the query function separately and not client-controlled.

Use `defineQueryWithContext` to define a query that takes a context parameter:

```ts
type MyZeroContext = {
  userID: string;
};

const myPostsQuery = defineQueryWithContext<MyZeroContext>()(
  z.object({ isDraft: z.string() }),
  ({ context: { userID }, args: { isDraft } }) => {
    // Note: User cannot control context.userID, so this safely
    // restricts the query to the user's own posts.
    return zql.post
      .where('authorID', userID)
      .where('isDraft', isDraft);
  },
);
```

## queries.ts

By convention, queries are listed in a central `queries.ts` file. This allows them to be easily used on both the client and server:

```ts
import { defineQuery } from '@rocicorp/zero';
import { zql } from './schema.ts';
import z from "zod";

export const queries = {
  posts: {
    get: defineQuery(
      z.string(),
      id => zql.post.where('id', id)
    ),
    byAuthor: defineQuery(
      z.object({
        authorID: z.string(),
        includeDrafts: z.boolean().optional(),
      }),
      ({ args: { authorID, includeDrafts } }) => {
        let q = zql.post.where('authorID', authorID);
        if (!includeDrafts) {
          q = q.where('isDraft', false);
        }
        return q;
      }
    ),
  }
}
```

You can use as many levels of nesting as you want to organize your queries. And as your application grows, you can move queries to different files to keep them organized:

```ts
// zero/queries.ts
import {postQueries} from 'zero/queries/posts.ts';
import {userQueries} from 'zero/queries/users.ts';

export const queries = {
  posts: postQueries,
  users: userQueries,
}
```

## Registration

Before you can use your queries, you need to register them with Zero.

In React or SolidJS, you'll do this by passing the `queries` object to the `ZeroProvider` component:

```tsx
import { ZeroProvider } from '@rocicorp/zero/react';
import { queries } from 'zero/queries.ts';

<ZeroProvider queries={queries}>
  <App />
</ZeroProvider>
```

If you use the `Zero` class directly, you can pass the `queries` object to the `Zero` constructor:

```ts
import { Zero } from '@rocicorp/zero';
import { queries } from 'zero/queries.ts';

const zero = new Zero({
  queries,
});
```

## Running Queries

### Reactively

The most common way to use queries is with the `useQuery` reactive hooks from the [React](react) or [SolidJS](solid) bindings:

```tsx
import { useZero, useQuery } from '@rocicorp/zero/react';
import { Schema } from 'zero/schema.ts';
import { queries, Queries } from 'zero/queries.ts';

function App() {
  const zero = useZero<Schema, Queries>();
  const [posts] = useQuery(queries.posts.get('user123'));
  return <div>{posts.map(post => <div key={post.id}>{post.title}</div>)}</div>;
}
```

These functions integrate with the associated frameworks to automatically re-render the UI when a query changes.

### Manually

You can also call `materialize()` on a query to manually create a _view_ outside of a UI framework:

```ts
const myView = zero.queries.posts
  .byAuthorID('user123')
  .materialize();

for (let post of myView.data) {
  console.log(post.title);
}
```

The view is automatically kept up to date by Zero as the underlying data changes. You can add a listener to the view to be notified when the data changes:

```ts
myView.addListener((posts) => {
  console.log(posts);
});
```

### Once

You usually want to subscribe to a query in a reactive UI, but every so often you'll need to run a query just once. To do this, use the `run()` method:

```tsx
const results = await z.query.issues.byPriority('high').run();
```

By default, `run()` only returns results that are currently available on the client. That is, it returns the data that would be given for [`result.type === 'unknown'`](#completeness).

If you want to wait for the server to return results, pass `{type: 'complete'}` to `run`:

```tsx
const results = await z.query.issues.byPriority('high')
  .run({type: 'complete'});
```

### For Preloading

Almost all Zero apps will want to preload some data in order to maximize the feel of instantaneous UI transitions.

Because preload queries are often much larger than a screenful of UI, Zero provides a special `preload()` helper to avoid the overhead of materializing the result into JS objects:

```tsx
// Preload a large number of the inbox query results.
z.query.issues.inbox({
  sort: 'created',
  sortDirection: 'desc',
  limit: 1000,
}).preload();
```

## Server Setup

In order for queries to sync, you must provide an implementation of the `queries` endpoint on your server. `zero-cache` calls this endpoint to get the ZQL for each query.

### Registering the Endpoint

Use [`ZERO_QUERIES_URL`](./zero-cache-config#get-queries-url) to tell `zero-cache` where to find your `get-queries` implementation:

```bash
export ZERO_QUERIES_URL="http://localhost:3000/api/zero/queries"
npx zero-cache-dev
```

### Implementing the Endpoint

The `@rocicorp/zero` package provides the `handleGetQueriesRequest`, `queryByName`, and `withValidation` functions to make it easy to implement the endpoint.

For example, with [Hono](https://hono.dev):

```ts
import { withValidation, queryByName, ReadonlyJSONValue } from "@rocicorp/zero";
import { handleGetQueriesRequest } from "@rocicorp/zero/server";
import { schema } from "schema.ts";
import { queries } from "queries.ts";

app.post("/queries", async (c) => {
  const userID = await authenticateUser(c.req.raw);
  const context = { userID };
  return await c.json(
    await handleGetQueriesRequest(
      (name, args) => getQuery(context, name, args),
      schema,
      c.req.raw
    )
  );
});

function getQuery(
    context: { userID: string },
    name: string,
    args: readonly ReadonlyJSONValue[],
  ) {
  const q = queryByName(name);
  if (!q) {
    throw new Error(`No such query: ${name}`);
  }
  return withValidation(q)({context,args});
}
```

`handleGetQueriesRequest` accepts a standard `Request` and returns a JSON object which can be serialized and returned by your server framework of choice.

`queryByName` looks up the query by name in the `queries` object.

`withValidation` uses the `validator` function you provided when defining the query to validate the arguments passed to the query. If validation fails, invoking the synced queries throws and an error is returned to the client.

`withValidation` always takes a `context` argument as its first parameter, whether or not the query was defined with `defineQueryWithContext`. If the query was defined with `defineQueryWithContext`, the context is passed into the query function. Otherwise, the context is ignored and anything can be passed to it.

### Handling Errors

If the queries endpoint returns an HTTP or network error, it will be reported to the client with using the `type` and `error` fields on the query details object:

```ts
const [posts, details] = useQuery(
  queries.posts.byAuthorID('user123'))
);
if (details.type === 'error') {
  return <div>Error loading posts: {details.error.message}</div>;
}
```

Or using the low-level API:

```ts
// Materialize a view of a query
const postsView = queries.posts.byAuthorID('user123').materialize();
postsView.addListener((posts, resultType, error) => {
  if (resultType === 'error') {
    console.error('Error loading posts', error);
  }
});
```

### Custom Queries URL

By default, synced queries use the URL specified in the `ZERO_QUERIES_URL` parameter.

However you can customize this on a per-client basis. To do so, list multiple comma-separted URLs in the `ZERO_QUERIES_URL` parameter:

```bash
ZERO_QUERIES_URL='https://api.example.com/queries,https://api.staging.example.com/queries'
```

Then choose one of those URLs by passing it to `queriesURL` on the `Zero` constructor:

```ts
const zero = new Zero({
  schema,
  queries,
  queriesURL: 'https://api.staging.example.com/queries',
});
```

### URL Patterns

The strings listed in `ZERO_QUERIES_URL` can also be [`URLPatterns`](https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API):

```bash
ZERO_QUERIES_URL="https://mybranch-*.preview.myapp.com/queries"
```

This queries URL will allow clients to choose URLs like:
- `https://mybranch-aaa.preview.myapp.com/queries` ‚úÖ
- `https://mybranch-bbb.preview.myapp.com/queries` ‚úÖ

But rejects URLs like:
- `https://preview.myapp.com/queries` ‚ùå (missing subdomain)
- `https://malicious.com/queries` ‚ùå (different domain)
- `https://mybranch-123.preview.myapp.com/queries/extra` ‚ùå (extra path)
- `https://mybranch-123.preview.myapp.com/other` ‚ùå (different path)

<Note emoji="ü•á" heading="Pro Tip (tm)">
Because URLPattern is a web standard, you can test them right in your browser:
  <img alt="URL Pattern"
    src="/images/mutators/url-pattern.png"/>
</Note>

For more information, see the [URLPattern docs](https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API).

## Completeness

Zero immediately returns the data for a query it has on the client, then falls back to the server for any missing data. Sometimes it's useful to know the difference between these two types of results. To do so, use the `result` from `useQuery`:

```tsx
const [issues, issuesResult] = useQuery(z.query.issues.inbox());
if (issuesResult.type === 'complete') {
  console.log('All data is present');
} else {
  console.log('Some data is missing');
}
```

The possible values of `result.type` are currently `complete` and `unknown`.

The `complete` value is currently only returned when Zero has received the server result. In the future, Zero will be able to return this result type when it _knows_ that all possible data for this query is already available locally. Additionally, we plan to add a `prefix` result for when the data is known to be a prefix of the complete result. See [Consistency](#consistency) for more information.

## Missing Data

It is inevitable that there will be cases where the requested data cannot be found. Because Zero returns local results immediately, and server results asynchronously, displaying "not found" / 404 UI can be slightly tricky. If you just use a simple existence check, you will often see the 404 UI flicker while the server result loads:

```tsx
const [issue, issuesResult] = useQuery(
  z.query.issues.get('some-id'),
);

// ‚ùå This causes flickering of the UI
if (!issue) {
  return <div>404 Not Found</div>;
} else {
  return <div>{issue}</div>;
}
```

The way to do this correctly is to only display the "not found" UI when the result type is `complete`. This way the 404 page is slow but pages with data are still just as fast.

```tsx
const [issue, issueResult] = useQuery(
  z.query.issues.get('some-id'),
);

if (!issue && issueResult.type === 'complete') {
  return <div>404 Not Found</div>;
}

if (!issue) {
  return null;
}

return <div>{issue}</div>;
```

## Granular Updates

You can use the [`materialize()`](#manually) method to create a view that you can listen to for changes.

However, this will only tell you when the view has changed and give you the complete new result. It won't tell you _what_ changed.

To know what changed, you can create your own custom `View` implementation:

```ts
// Inside the View class
// Instead of storing the change, we invoke some callback
push(change: Change): void {
  switch (change.type) {
    case 'add':
      this.#onAdd?.(change)
      break
    case 'remove':
      this.#onRemove?.(change)
      break
    case 'edit':
      this.#onEdit?.(change)
      break
    case 'child':
      this.#onChild?.(change)
      break
    default:
      throw new Error(`Unknown change type: ${change['type']}`)
  }
}
```

For examples, see the `View` implementations in [`zero-vue`](https://github.com/danielroe/zero-vue/blob/f25808d4b7d1ef0b8e01a5670d7e3050d6a64bbf/src/view.ts#L77-L89) or [`zero-solid`](https://github.com/rocicorp/mono/blob/51995101d0657519207f1c4695a8765b9016e07c/packages/zero-solid/src/solid-view.ts#L119-L131).

## Query Lifecycle

<ImageLightbox
  src="/images/reading-data/query-lifecycle.svg"
  caption="The lifecycle of a ZQL query."
  className="invert dark:invert-0"
/>

Queries can be either _active_ or _cached_. An active query is one that is currently being used by the application. Cached queries are not currently in use, but continue syncing in case they are needed again soon.

Active queries are created one of four ways:

1. The app calls `q.materialize()` to get a `View`.
2. The app uses a framework binding like React's `useQuery(q)`.
3. The app calls [`preload()`](#preloading) to sync larger queries without a view.
4. The app calls `q.run()` to get a single result.

Active queries can be _deactivated_ according to how they were created:

1. For `materialize()` queries, the UI calls `destroy()` on the view.
2. For `useQuery()`, the UI unmounts the component (which calls `destroy()` under the covers).
3. For `preload()`, the UI calls `cleanup()` on the return value of `preload()`.
4. For `run()`, queries are automatically deactivated immediately after the result is returned.

Additionally when a Zero instance closes, all active queries are automatically deactivated. This also happens when the containing page or script is unloaded.

### TTLs

Each query has a `ttl` that controls how long it stays cached.

<Note emoji="üí°" heading="The TTL clock only ticks while Zero is running">
If the user closes all tabs for your app, Zero stops running and the time that elapses doesn't count toward any TTLs.

You do not need to account for such time when choosing a TTL ‚Äì you only need to account for time your app is running *without* a query.
</Note>

### TTL Defaults

In most cases, the default TTL should work well:

* `preload()` queries default to `ttl:'none'`, meaning they are not cached at all, and will stop syncing immediately when deactivated. But because `preload()` queries are typically registered at app startup and never shutdown, and [because the ttl clock only ticks while Zero is running](#the-ttl-clock-only-ticks-while-zero-is-running), this means that preload queries never get unregistered.
* Other queries have a default `ttl` of `5m` (five minutes).

### Setting Different TTLs

You can override the default TTL with the `ttl` parameter:

```ts
// With useQuery():
const [user] = useQuery(
    z.query.user.byID('id', userId),
    {ttl: '5m'});

// With preload():
z.query.user.byID('id', userId).preload(
    {ttl: '5m'});

// With run():
const user = await z.query.user.byID('id', userId).run(
    {ttl: '5m'});

// With materialize():
const view = z.query.user.byID('id', userId).materialize(
    {ttl: '5m'});
```

TTLs up to `10m` (ten minutes) are currently supported. The following formats are allowed:

| Format    | Meaning                                                   |
| --------- | --------------------------------------------------------- |
| `none`    | No caching. Query will immediately stop when deactivated. |
| `%ds`     | Number of seconds.                                        |
| `%dm`     | Number of minutes.                                        |

### Choosing a TTL

If you choose a different TTL, you should consider how likely it is that the query will be reused, and how far into the future this reuse will occur. Here are some guidelines to help you choose a TTL for common query types:

#### Preload Queries

These queries load the most commonly needed data for your app. They are typically larger, run with the `preload()` method, and stay running the entire time your app is running.

Because these queries run the entire time Zero runs, they do not need any TTL to keep them alive. And using a `ttl` for them is wasteful since when your app changes its preload query, it will end up running the old preload query *and* the new preload query, even though the app only cares about the new one.

**Recommendation:** `ttl: 'none'` *(the default for `preload()`)*.

#### Navigational Queries

These queries load data specific to a route. They are typically smaller and run with the `useQuery()` method. It is useful to cache them for a short time, so that they can be reactivated quickly if the user navigates back to the route.

**Recommendation:** `ttl: '5m'` *(the default for `useQuery()`)*.

#### Ephemeral Queries

These queries load data for a specific, short-lived user interaction and often come in large numbers (e.g., typeahead search).

The chance of any specific ephemeral query being reused is low, so the benefit of caching them is also low.

**Recommendation:** `useQuery(..., {ttl: 'none'})`)*.

### Why Zero TTLs are Short

Zero queries are not free.

Just as in any database, queries consume resources on both the client and server. Memory is used to keep metadata about the query, and disk storage is used to keep the query's current state.

We do drop this state after we haven't heard from a client for awhile, but this is only a partial improvement. If the client returns, we have to re-run the query to get the latest data.

This means that we do not actually *want* to keep queries active unless there is a good chance they will be needed again soon.

The default Zero TTL values might initially seem too short, but they are designed to work well with the way Zero's TTL clock works and strike a good balance between keeping queries alive long enough to be useful, while not keeping them alive so long that they consume resources unnecessarily.

<Note emoji="üßë‚Äçüè´" type="warning" heading="Longer TTLs are disallowed">
Previous versions of Zero allowed longer TTLs. The API still supports these, but they are clamped to `10m` and Zero prints a warning.

If you think you need longer TTLs, please [let us know](https://discord.rocicorp.dev). We are still iterating on these APIs and may have missed something. Alternately we may be able to help you achieve your goal a different way.
</Note>

---

## Custom Server Implementation

It is possible to implement the `ZERO_QUERIES_URL` endpoint without using Zero's TypeScript libraries, or even in a different language entirely.

The endpoint receives a `POST` request with a JSON body of the form:

```ts
type QueriesRequestBody = {
    id: string;
    name: string;
    args: readonly ReadonlyJSONValue[];
}[]
```

And responds with:

```ts
type QueriesResponseBody = ({
    id: string;
    name: string;
    // See https://github.com/rocicorp/mono/blob/main/packages/zero-protocol/src/ast.ts
    ast: AST;
} | {
    error: "app";
    id: string;
    name: string;
    details: ReadonlyJSONValue;
} | {
    error: "zero";
    id: string;
    name: string;
    details: ReadonlyJSONValue;
} | {
    error: "http";
    id: string;
    name: string;
    status: number;
    details: ReadonlyJSONValue;
})[]
```

## Consistency

Zero always syncs a consistent partial replica of the backend database to the client. This avoids many common consistency issues that come up in classic web applications. But there are still some consistency issues to be aware of when using Zero.

For example, imagine that you have a bug database w/ 10k issues. You preload the first 1k issues sorted by created.

The user then does a query of issues assigned to themselves, sorted by created. Among the 1k issues that were preloaded imagine 100 are found that match the query. Since the data we preloaded is in the same order as this query, we are guaranteed that any local results found will be a _prefix_ of the server results.

The UX that result is nice: the user will see initial results to the query instantly. If more results are found server-side, those results are guaranteed to sort below the local results. There's no shuffling of results when the server response comes in.

Now imagine that the user switches the sort to ‚Äòsort by modified‚Äô. This new query will run locally, and will again find some local matches. But it is now unlikely that the local results found are a prefix of the server results. When the server result comes in, the user will probably see the results shuffle around.

To avoid this annoying effect, what you should do in this example is also preload the first 1k issues sorted by modified desc. In general for any query shape you intend to do, you should preload the first `n` results for that query shape with no filters, in each sort you intend to use.

<Note slug="no-duplicate-rows" heading="Zero does not sync duplicate rows">
Zero syncs the *union* of all active queries' results. You don't have to worry about syncing many sorts of the same query when it's likely the results will overlap heavily.

</Note>

In the future, we will be implementing a consistency model that fixes these issues automatically. We will prevent Zero from returning local data when that data is not known to be a prefix of the server result. Once the consistency model is implemented, preloading can be thought of as purely a performance thing, and not required to avoid unsightly flickering.

## Disabling Old Queries

If you don't want clients to be able to run arbitrary ZQL queries anymore, you can disable them with the `enableLegacyQueries` flag in your Zero schema:

```ts
export const schema = createSchema({
  // ...
  enableLegacyQueries: false,
});
```

The `schema` object itself has the same field. So if you use a generator like `drizzle-zero`, you can just add the flag yourself:

```ts
import { Schema as ZeroSchema } from '@rocicorp/zero';
import {schema as genSchema} from './schema.gen';

export const schema = {
  ...genSchema,
  enableLegacyQueries: false,
} as const satisfies ZeroSchema;
```

You will still be able to call `useQuery(z.query.myTable)` or `useQuery(builder.myTable)`, but those queries won't sync. Only queries defined with `syncedQuery` will sync.

## Local-Only Queries

It can sometime be useful to run queries only on the client. For example, to implement typeahead search, it really doesn't make sense to register every single keystroke with the server.

See [disabling legacy queries](#disabling-old-queries) for how to do this.
