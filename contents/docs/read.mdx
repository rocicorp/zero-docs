---
title: Queries
description: Reading and Syncing Data
---

## Overview

Zero has two types of queries: [ZQL Queries](./zql) and [Custom Queries](./queries).

ZQL queries are a low-level primitive for querying data. You can think of them like bare SQL statements in a traditional database.

Custom queries are named functions that dynamically compute a ZQL query. They are comparable to stored procedures in a traditional database.

Many features in Zero work with either type of query, but only custom queries can sync.


## Running Queries

### Reactively

The most common way to use queries is with the `useQuery` reactive hooks from the [React](react) or [SolidJS](solid) bindings:

```tsx
import { useZero, useQuery } from '@rocicorp/zero/react';
import { Schema } from 'zero/schema.ts';
import { queries, Queries } from 'zero/queries.ts';

function App() {
  const zero = useZero<Schema, Queries>();
  const [posts] = useQuery(queries.posts.get('user123'));
  return <div>{posts.map(post => <div key={post.id}>{post.title}</div>)}</div>;
}
```

These functions integrate with the associated frameworks to automatically re-render the UI when a query changes.

### Manually

You can also call `materialize()` on a query to manually create a _view_ outside of a UI framework:

```ts
const myView = zero.queries.posts
  .byAuthorID('user123')
  .materialize();

for (let post of myView.data) {
  console.log(post.title);
}
```

The view is automatically kept up to date by Zero as the underlying data changes. You can add a listener to the view to be notified when the data changes:

```ts
myView.addListener((posts) => {
  console.log(posts);
});
```

### Once

You usually want to subscribe to a query in a reactive UI, but every so often you'll need to run a query just once. To do this, use the `run()` method:

```tsx
const results = await z.query.issues.byPriority('high').run();
```

By default, `run()` only returns results that are currently available on the client. That is, it returns the data that would be given for [`result.type === 'unknown'`](#completeness).

If you want to wait for the server to return results, pass `{type: 'complete'}` to `run`:

```tsx
const results = await z.query.issues.byPriority('high')
  .run({type: 'complete'});
```

## Completeness

Zero immediately returns the data for a query it has on the client, then falls back to the server for any missing data. Sometimes it's useful to know the difference between these two types of results. To do so, use the `result` from `useQuery`:

```tsx
const [issues, issuesResult] = useQuery(z.query.issues.inbox());
if (issuesResult.type === 'complete') {
  console.log('All data is present');
} else {
  console.log('Some data is missing');
}
```

The possible values of `result.type` are currently `complete` and `unknown`.

The `complete` value is currently only returned when Zero has received the server result. In the future, Zero will be able to return this result type when it _knows_ that all possible data for this query is already available locally. Additionally, we plan to add a `prefix` result for when the data is known to be a prefix of the complete result. See [Consistency](#consistency) for more information.

## Missing Data

It is inevitable that there will be cases where the requested data cannot be found. Because Zero returns local results immediately, and server results asynchronously, displaying "not found" / 404 UI can be slightly tricky. If you just use a simple existence check, you will often see the 404 UI flicker while the server result loads:

```tsx
const [issue, issuesResult] = useQuery(
  z.query.issues.get('some-id'),
);

// ❌ This causes flickering of the UI
if (!issue) {
  return <div>404 Not Found</div>;
} else {
  return <div>{issue}</div>;
}
```

The way to do this correctly is to only display the "not found" UI when the result type is `complete`. This way the 404 page is slow but pages with data are still just as fast.

```tsx
const [issue, issueResult] = useQuery(
  z.query.issues.get('some-id'),
);

if (!issue && issueResult.type === 'complete') {
  return <div>404 Not Found</div>;
}

if (!issue) {
  return null;
}

return <div>{issue}</div>;
```

## Granular Updates

You can use the [`materialize()`](#manually) method to create a view that you can listen to for changes.

However, this will only tell you when the view has changed and give you the complete new result. It won't tell you _what_ changed.

To know what changed, you can create your own custom `View` implementation:

```ts
// Inside the View class
// Instead of storing the change, we invoke some callback
push(change: Change): void {
  switch (change.type) {
    case 'add':
      this.#onAdd?.(change)
      break
    case 'remove':
      this.#onRemove?.(change)
      break
    case 'edit':
      this.#onEdit?.(change)
      break
    case 'child':
      this.#onChild?.(change)
      break
    default:
      throw new Error(`Unknown change type: ${change['type']}`)
  }
}
```

For examples, see the `View` implementations in [`zero-vue`](https://github.com/danielroe/zero-vue/blob/f25808d4b7d1ef0b8e01a5670d7e3050d6a64bbf/src/view.ts#L77-L89) or [`zero-solid`](https://github.com/rocicorp/mono/blob/51995101d0657519207f1c4695a8765b9016e07c/packages/zero-solid/src/solid-view.ts#L119-L131).

## Consistency

Zero always syncs a consistent partial replica of the backend database to the client. This avoids many common consistency issues that come up in classic web applications. But there are still some consistency issues to be aware of when using Zero.

For example, imagine that you have a bug database w/ 10k issues. You preload the first 1k issues sorted by created.

The user then does a query of issues assigned to themselves, sorted by created. Among the 1k issues that were preloaded imagine 100 are found that match the query. Since the data we preloaded is in the same order as this query, we are guaranteed that any local results found will be a _prefix_ of the server results.

The UX that result is nice: the user will see initial results to the query instantly. If more results are found server-side, those results are guaranteed to sort below the local results. There's no shuffling of results when the server response comes in.

Now imagine that the user switches the sort to ‘sort by modified’. This new query will run locally, and will again find some local matches. But it is now unlikely that the local results found are a prefix of the server results. When the server result comes in, the user will probably see the results shuffle around.

To avoid this annoying effect, what you should do in this example is also preload the first 1k issues sorted by modified desc. In general for any query shape you intend to do, you should preload the first `n` results for that query shape with no filters, in each sort you intend to use.

<Note slug="no-duplicate-rows" heading="Zero does not sync duplicate rows">
Zero syncs the *union* of all active queries' results. You don't have to worry about syncing many sorts of the same query when it's likely the results will overlap heavily.

</Note>

In the future, we will be implementing a consistency model that fixes these issues automatically. We will prevent Zero from returning local data when that data is not known to be a prefix of the server result. Once the consistency model is implemented, preloading can be thought of as purely a performance thing, and not required to avoid unsightly flickering.
