---
title: Queries
---

## Defining Queries

A Zero _query_ is basically just a function that returns a hunk of [ZQL](reading-data) describing the data to read.

Create queries with the `defineQuery` function:

```ts
import { defineQuery } from '@rocicorp/zero';
import { zql } from './schema.ts';
import z from "zod";

const myPostsQuery = defineQuery(
  z.object({ id: z.string() }),
  ({ args: { id } }) => zql.post.where('authorID', id),
);
```

## Query Parameters

The first argument to `defineQuery` is a *validator* that defines the query's parameters. We use [Zod](https://zod.dev/) in these examples, but you can use any validation library that implements [Standard Schema](https://standardschema.dev/).

Validation is needed because Zero queries also run [on your server](#server-setup), where the inputs are untrusted. These inputs are validated using the validator you provide.

Zero supports only one formal parameter for each query, but it can be of any type you want. The convention is to use an object with named fields for extensibility:

```ts
const searchPosts = defineQuery(
  z.object({
    title: z.string().optional(),
    authorID: z.string().optional(),
    isOpen: z.boolean().optional(),
  }),
  ({ args: { title, authorID, isOpen } }) => {
    let q = zql.post;
    if (title !== undefined) {
      q = q.where('title', title);
    }
    if (authorID !== undefined) {
      q = q.where('authorID', authorID);
    }
    if (isOpen !== undefined) {
      q = q.where('isOpen', isOpen);
    }
    return q;
  },
);
```

## Query Context

Query parameters are supplied by the client application and passed to the server automatically by Zero. This makes them unsuitable for authentication data, since the user could modify them.

For this reason, Zero queries also support a `context` parameter. When used [on the server](#server-setup), the context is passed to the query function separately and not client-controlled.

Use `defineQueryWithContext` to define a query that takes a context parameter:

```ts
type MyZeroContext = {
  userID: string;
};

const myPostsQuery = defineQueryWithContext<MyZeroContext>()(
  z.object({ isDraft: z.string() }),
  ({ context: { userID }, args: { isDraft } }) => {
    // Note: User cannot control context.userID, so this safely
    // restricts the query to the user's own posts.
    return zql.post
      .where('authorID', userID)
      .where('isDraft', isDraft);
  },
);
```

## queries.ts

Queries are conventionally defined in a central `queries.ts` file. This allows them to be easily used on both the client and server:

```ts
import { defineQuery } from '@rocicorp/zero';
import { zql } from './schema.ts';
import z from "zod";

export const queries = {
  posts: {
    get: defineQuery(
      z.string(),
      id => zql.post.where('id', id)
    ),
    byAuthor: defineQuery(
      z.object({
        authorID: z.string(),
        includeDrafts: z.boolean().optional(),
      }),
      ({ args: { authorID, includeDrafts } }) => {
        let q = zql.post.where('authorID', authorID);
        if (!includeDrafts) {
          q = q.where('isDraft', false);
        }
        return q;
      }
    ),
  }
}
```

You can use as many levels of nesting as you want to organize your queries. And as your application grows, you can move queries to different files to keep them organized:

```ts
// zero/queries.ts
import {postQueries} from 'zero/queries/posts.ts';
import {userQueries} from 'zero/queries/users.ts';

export const queries = {
  posts: postQueries,
  users: userQueries,
}
```

## Registering Queries

Before you can use your queries, you need to register them with Zero. In React or SolidJS, you'll do this by passing the `queries` object to the `ZeroProvider` component:

```tsx
import { ZeroProvider } from '@rocicorp/zero/react';
import { queries } from 'zero/queries.ts';

<ZeroProvider queries={queries}>
  <App />
</ZeroProvider>
```

If you use the `Zero` class directly, you can pass the `queries` object to the `Zero` constructor:

```ts
import { Zero } from '@rocicorp/zero';
import { queries } from 'zero/queries.ts';

const zero = new Zero({
  queries,
});
```

## Running Queries

### Reactively

The most common way to use queries is with the `useQuery` reactive hooks from the [React](react) or [SolidJS](solid) bindings:

```tsx
import { useZero, useQuery } from '@rocicorp/zero/react';
import { Schema } from 'zero/schema.ts';
import { queries, Queries } from 'zero/queries.ts';

function App() {
  const zero = useZero<Schema, Queries>();
  const [posts] = useQuery(queries.posts.get('user123'));
  return <div>{posts.map(post => <div key={post.id}>{post.title}</div>)}</div>;
}
```

These functions integrate with the associated frameworks to automatically re-render the UI when a query changes.

### Manually

You can also call `materialize()` on a query to manually create a _view_ outside of a UI framework:

```ts
const myView = zero.queries.posts
  .byAuthorID('user123')
  .materialize();

for (let post of myView.data) {
  console.log(post.title);
}
```

The view is automatically kept up to date by Zero as the underlying data changes. You can add a listener to the view to be notified when the data changes:

```ts
myView.addListener((posts) => {
  console.log(posts);
});
```

### Once

You usually want to subscribe to a query in a reactive UI, but every so often you'll need to run a query just once. To do this, use the `run()` method:

```tsx
const results = await z.query.issues.byPriority('high').run();
```

By default, `run()` only returns results that are currently available on the client. That is, it returns the data that would be given for [`result.type === 'unknown'`](#completeness).

If you want to wait for the server to return results, pass `{type: 'complete'}` to `run`:

```tsx
const results = await z.query.issues.byPriority('high')
  .run({type: 'complete'});
```

### For Preloading

Almost all Zero apps will want to preload some data in order to maximize the feel of instantaneous UI transitions.

Because preload queries are often much larger than a screenful of UI, Zero provides a special `preload()` helper to avoid the overhead of materializing the result into JS objects:

```tsx
// Preload a large number of the inbox query results.
z.query.issues.inbox({
  sort: 'created',
  sortDirection: 'desc',
  limit: 1000,
}).preload();
```

## Server Setup

In order for queries to sync, you must provide an implementation of the `queries` endpoint on your server. `zero-cache` calls this endpoint to get the ZQL for each query.

### Registering the Endpoint

Use [`ZERO_QUERIES_URL`](./zero-cache-config#get-queries-url) to tell `zero-cache` where to find your `get-queries` implementation:

```bash
export ZERO_QUERIES_URL="http://localhost:3000/api/zero/queries"
npx zero-cache-dev
```

### Implementing the Endpoint

The `@rocicorp/zero` package provides the `handleGetQueriesRequest`, `queryByName`, and `withValidation` functions to make it easy to implement the endpoint.

For example, with [Hono](https://hono.dev):

```ts
import { withValidation, queryByName, ReadonlyJSONValue } from "@rocicorp/zero";
import { handleGetQueriesRequest } from "@rocicorp/zero/server";
import { schema } from "schema.ts";
import { queries } from "queries.ts";

app.post("/queries", async (c) => {
  const userID = await authenticateUser(c.req.raw);
  const context = { userID };
  return await c.json(
    await handleGetQueriesRequest(
      (name, args) => getQuery(context, name, args),
      schema,
      c.req.raw
    )
  );
});

function getQuery(
    context: { userID: string },
    name: string,
    args: readonly ReadonlyJSONValue[],
  ) {
  const q = queryByName(name);
  if (!q) {
    throw new Error(`No such query: ${name}`);
  }
  return withValidation(q)({context,args});
}
```

`handleGetQueriesRequest` accepts a standard `Request` and returns a JSON object which can be serialized and returned by your server framework of choice.

`queryByName` looks up the query by name in the `queries` object.

`withValidation` uses the `validator` function you provided when defining the query to validate the arguments passed to the query. If validation fails, invoking the synced queries throws and an error is returned to the client.

`withValidation` always takes a `context` argument as its first parameter, whether or not the query was defined with `defineQueryWithContext`. If the query was defined with `defineQueryWithContext`, the context is passed into the query function. Otherwise, the context is ignored and anything can be passed to it.

### Handling Errors

If the queries endpoint returns an HTTP or network error, it will be reported to the client with using the `type` and `error` fields on the query details object:

```ts
const [posts, details] = useQuery(
  queries.posts.byAuthorID('user123'))
);
if (details.type === 'error') {
  return <div>Error loading posts: {details.error.message}</div>;
}
```

Or using the low-level API:

```ts
// Materialize a view of a query
const postsView = queries.posts.byAuthorID('user123').materialize();
postsView.addListener((posts, resultType, error) => {
  if (resultType === 'error') {
    console.error('Error loading posts', error);
  }
});
```

### Custom Queries URL

By default, synced queries use the URL specified in the `ZERO_QUERIES_URL` parameter.

However you can customize this on a per-client basis. To do so, list multiple comma-separted URLs in the `ZERO_QUERIES_URL` parameter:

```bash
ZERO_QUERIES_URL='https://api.example.com/queries,https://api.staging.example.com/queries'
```

Then choose one of those URLs by passing it to `queriesURL` on the `Zero` constructor:

```ts
const zero = new Zero({
  schema,
  queries,
  queriesURL: 'https://api.staging.example.com/queries',
});
```

### URL Patterns

The strings listed in `ZERO_QUERIES_URL` can also be [`URLPatterns`](https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API):

```bash
ZERO_QUERIES_URL="https://mybranch-*.preview.myapp.com/queries"
```

This queries URL will allow clients to choose URLs like:
- `https://mybranch-aaa.preview.myapp.com/queries` ‚úÖ
- `https://mybranch-bbb.preview.myapp.com/queries` ‚úÖ

But rejects URLs like:
- `https://preview.myapp.com/queries` ‚ùå (missing subdomain)
- `https://malicious.com/queries` ‚ùå (different domain)
- `https://mybranch-123.preview.myapp.com/queries/extra` ‚ùå (extra path)
- `https://mybranch-123.preview.myapp.com/other` ‚ùå (different path)

<Note emoji="ü•á" heading="Pro Tip (tm)">
Because URLPattern is a web standard, you can test them right in your browser:
  <img alt="URL Pattern"
    src="/images/mutators/url-pattern.png"/>
</Note>

For more information, see the [URLPattern docs](https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API).


## Completeness

Zero immediately returns the data for a query it has on the client, then falls back to the server for any missing data. Sometimes it's useful to know the difference between these two types of results. To do so, use the `result` from `useQuery`:

```tsx
const [issues, issuesResult] = useQuery(z.query.issues.inbox());
if (issuesResult.type === 'complete') {
  console.log('All data is present');
} else {
  console.log('Some data is missing');
}
```

The possible values of `result.type` are currently `complete` and `unknown`.

The `complete` value is currently only returned when Zero has received the server result. In the future, Zero will be able to return this result type when it _knows_ that all possible data for this query is already available locally. Additionally, we plan to add a `prefix` result for when the data is known to be a prefix of the complete result. See [Consistency](#consistency) for more information.

## Handling Missing Data

It is inevitable that there will be cases where the requested data cannot be found. Because Zero returns local results immediately, and server results asynchronously, displaying "not found" / 404 UI can be slightly tricky. If you just use a simple existence check, you will often see the 404 UI flicker while the server result loads:

```tsx
const [issue, issuesResult] = useQuery(
  z.query.issues.get('some-id'),
);

// ‚ùå This causes flickering of the UI
if (!issue) {
  return <div>404 Not Found</div>;
} else {
  return <div>{issue}</div>;
}
```

The way to do this correctly is to only display the "not found" UI when the result type is `complete`. This way the 404 page is slow but pages with data are still just as fast.

```tsx
const [issue, issueResult] = useQuery(
  z.query.issues.get('some-id'),
);

if (!issue && issueResult.type === 'complete') {
  return <div>404 Not Found</div>;
}

if (!issue) {
  return null;
}

return <div>{issue}</div>;
```

## Granular View Updates

You can use the [`materialize()`](#manually) method to create a view that you can listen to for changes.

However, this will only tell you when the view has changed and give you the complete new result. It won't tell you _what_ changed.

To know what changed, you can create your own custom `View` implementation:

```ts
// Inside the View class
// Instead of storing the change, we invoke some callback
push(change: Change): void {
  switch (change.type) {
    case 'add':
      this.#onAdd?.(change)
      break
    case 'remove':
      this.#onRemove?.(change)
      break
    case 'edit':
      this.#onEdit?.(change)
      break
    case 'child':
      this.#onChild?.(change)
      break
    default:
      throw new Error(`Unknown change type: ${change['type']}`)
  }
}
```

For examples, see the `View` implementations in [`zero-vue`](https://github.com/danielroe/zero-vue/blob/f25808d4b7d1ef0b8e01a5670d7e3050d6a64bbf/src/view.ts#L77-L89) or [`zero-solid`](https://github.com/rocicorp/mono/blob/51995101d0657519207f1c4695a8765b9016e07c/packages/zero-solid/src/solid-view.ts#L119-L131).

## Custom Server Implementation

It is possible to implement the `ZERO_QUERIES_URL` endpoint without using Zero's TypeScript libraries, or even in a different language entirely.

The endpoint receives a `POST` request with a JSON body of the form:

```ts
type QueriesRequestBody = {
    id: string;
    name: string;
    args: readonly ReadonlyJSONValue[];
}[]
```

And responds with:

```ts
type QueriesResponseBody = ({
    id: string;
    name: string;
    // See https://github.com/rocicorp/mono/blob/main/packages/zero-protocol/src/ast.ts
    ast: AST;
} | {
    error: "app";
    id: string;
    name: string;
    details: ReadonlyJSONValue;
} | {
    error: "zero";
    id: string;
    name: string;
    details: ReadonlyJSONValue;
} | {
    error: "http";
    id: string;
    name: string;
    status: number;
    details: ReadonlyJSONValue;
})[]
```

## Disabling Old Queries

If you don't want clients to be able to run arbitrary ZQL queries anymore, you can disable them with the `enableLegacyQueries` flag in your Zero schema:

```ts
export const schema = createSchema({
  // ...
  enableLegacyQueries: false,
});
```

The `schema` object itself has the same field. So if you use a generator like `drizzle-zero`, you can just add the flag yourself:

```ts
import { Schema as ZeroSchema } from '@rocicorp/zero';
import {schema as genSchema} from './schema.gen';

export const schema = {
  ...genSchema,
  enableLegacyQueries: false,
} as const satisfies ZeroSchema;
```

You will still be able to call `useQuery(z.query.myTable)` or `useQuery(builder.myTable)`, but those queries won't sync. Only queries defined with `syncedQuery` will sync.

## Local-Only Queries

It can sometime be useful to run queries only on the client. For example, to implement typeahead search, it really doesn't make sense to register every single keystroke with the server.

See [disabling legacy queries](#disabling-old-queries) for how to do this.

## Examples

See [ztunes](samples#ztunes), [zslack](samples#zslack), [zbugs](samples#zbugs), and [hello-zero-solid](samples#hello-zero-solid) for examples of complete apps using synced queries.

## How Queries Work

An implementation of each query exists on both the client and on your server:

<ImageLightbox
  src="/images/custom-queries/queries1.svg"
  caption="Query architecture"
  className="invert dark:invert-0"
/>

Often the implementations will be the same and can share their code. This is easy with full-stack frameworks
like [TanStack Start](https://tanstack.com/start) or [Next.js](https://nextjs.org/).

But the implementations don't have to be the same, or even compute the same result. For example, the server can add extra filters to enforce permissions that the client query does not.

## Life of a Query

Calling a query invokes the wrapped function and returns a ZQL expression. Pass that to `useQuery` on the client:

```tsx
const [posts] = useQuery(myPostsQuery('user123'));

return (
  <ul>
    {posts.map(post => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

Queries run client-side immediately. You get an instant result with any available local data:

<ImageLightbox
  src="/images/custom-queries/queries2.svg"
  caption="Registering a query"
  className="invert dark:invert-0"
/>

And just as with other ZQL queries, synced queries are live. Optimistic mutations are reflected immediatley and automatically:

<ImageLightbox
  src="/images/custom-queries/queries3.svg"
  caption="Local updates"
  className="invert dark:invert-0"
/>

### Query Subscription

When you run a synced query, `zero-client` "subscribes"
to the query by sending the query's name and arguments
to `zero-cache`.

Zero-cache then turns around and asks your server for the
definition of that query by calling its `/get-queries` endpoint:

<ImageLightbox
  src="/images/custom-queries/queries4.svg"
  caption="Query subscription"
  className="invert dark:invert-0"
/>

See [Server Setup](#server-setup) for details on implementing this endpoint. We provide
some TypeScript libraries to make it easy.

### Server Hydration

Once `zero-cache` has the query definition from your server, it creates an
instance of the query on the server, computes the initial result,
and returns the response to the client:

<ImageLightbox
  src="/images/custom-queries/queries5.svg"
  caption="Server result"
  className="invert dark:invert-0"
/>

These results are merged into the local datastore, updating client queries and the app as needed.

### Ongoing Sync

`zero-cache` receives updates from Postgres via logical replication.

It feeds these changes into all open queries, which are incrementally updated. The resulting deltas are sent to the clients, which merge them into their local datastore, updating client queries and the app as needed:

<ImageLightbox
  src="/images/custom-queries/queries6.svg"
  caption="Server result"
  className="invert dark:invert-0"
/>

