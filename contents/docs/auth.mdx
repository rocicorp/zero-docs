---
title: Authentication
---

You can authenticate Zero clients using either tokens or cookies.

## Tokens

If you have an opaque auth token, such as a JWT or a token from your auth provider, you can pass it to Zero's `auth` parameter:

```ts
const zero = new Zero({
  ...,
  auth: token,
});
```

Zero will forward this token to your [mutate](/docs/mutators) and [queries](/docs/queries) endpoints in the standard `Authorization` header, which you can use to authenticate the request as normal:

```ts
export function handleMutate(request: Request) {
  const session = await authenticate(
    request.headers.get('Authorization'));

  if (!session) {
    return json({error: 'Unauthorized'}, {status: 401});
  }

  // handle mutate request ...
}
```

## Cookies

Zero also supports cookie-based auth.

To enable it, set the [`ZERO_GET_QUERIES_FORWARD_COOKIES`](/docs/config#zero_get_queries_forward_cookies) and [`ZERO_MUTATE_FORWARD_COOKIES`](/docs/config#zero_mutate_forward_cookies) options to `true`:

```bash
ZERO_GET_QUERIES_FORWARD_COOKIES=true
ZERO_MUTATE_FORWARD_COOKIES=true
```

Zero will then forward all cookies sent to `cacheURL` to your [mutate](/docs/mutators) and [queries](/docs/queries) endpoints:

```tsx
<ZeroProvider {...{
  schema,
  // Cookies sent to zero.example.com will be forwarded to
  // api.example.com/mutate and api.example.com/queries.
  cacheURL: 'https://zero.example.com',
  mutateURL: 'https://api.example.com/mutate',
  queriesURL: 'https://api.example.com/queries',
}}>
  <App />
</ZeroProvider>
```

Cookies will show up in the normal HTTP `Cookie` header and you can authenticate these endpoints just like you would any API request.

For this to work, the `zero-cache` server and your API server must be running on the same root domain so that they can share cookies. This happens automatically during development, as long as your frontend and `zero-cache` are both running on localhost with different ports.

For production you'll need to do two things:

1. Run `zero-cache` on a subdomain of your main site (e.g., `zero.example.com` if your main site is `example.com`). Consult your hosting provider's docs, or your favorite LLM for how to configure this.
2. Set cookies from your main site with the `Domain` attribute set to your root domain (e.g., `.example.com`). If you use a third-party auth provider, consult their docs on how to do this. For example, for Better Auth, this is done with the [`crossSubDomainCookies`](https://www.better-auth.com/docs/concepts/cookies#cross-subdomain-cookies) feature.

## Auth Failure and Refresh

To mark a request as unauthorized, return a `401` or `403` status code from your [queries](/docs/queries) or [mutate](/docs/mutators) endpoint:

```ts
export function handleMutate(request: Request) {
  const session = await authenticate(request);

  if (!session) {
    return json({error: 'Forbidden'}, {status: 403});
  }

  // handle mutate request ...
}
```

This will cause Zero to disconnect from `zero-cache` and the [connection status](/docs/api/connection-state-todo) will change to `needs-auth`. You can then re-authenticate the user and call `zero.connection.connect()` to reconnect to `zero-cache`:

```tsx
function NeedsAuthDialog() {
  const connectionState = useZeroConnectionState();

  const refreshAuthToken = async () => {
    const token = await fetchNewToken();
    zero.connection.connect({auth: token});
  }

  if (connectionState.name === 'needs-auth') {
    return <div>
      <h1>Authentication Required</h1>
      <button onClick={refreshAuthToken}>Login</button>
    </div>;
  }

  return null;
}
```

Or, if you use cookie auth:

```tsx
function NeedsAuthDialog() {
  const connectionState = useZeroConnectionState();

  const refreshCookie = async () => {
    const cookie = await login();
    // No token needed since we use cookie auth
    zero.connection.connect();
  }

  if (connectionState.name === 'needs-auth') {
    return <div>
      <h1>Authentication Required</h1>
      <button onClick={refreshCookie}>Login</button>
    </div>;
  }

  return null;
```

## Permissions

Zero does not have (or need) a first-class permission system like [RLS](https://supabase.com/docs/guides/database/postgres/row-level-security).

Instead, you implement permissions by authenticating the user in your [queries](/docs/queries) and [mutators](/docs/mutators) endpoints, and creating a [Context](/docs/queries#context) object that contains the user's ID and other information. This context is passed to your queries and mutators and used to control what data the user can access.

See [Query Server Setup](/docs/queries#server-setup) and [Mutator Server Setup](/docs/mutators#server-setup) for an example of how to authenticate the user and create a context object.

## Permission Patterns

Here are a collection of common permissions patterns and how to implement them in Zero.

### Read Permisssions

#### Only Owned Rows

```ts
// Use the context's `userID` to filter the rows to only the
// ones owned by the user.
const myPosts = defineQueryWithContext<MyZeroContext>()(
  z.undefined(),
  ({ context: { userID } }) => {
    return zql.post.where('authorID', userID)
  },
);
```

#### Owned or Shared Rows

```ts
// Use the context's `userID` to filter the rows to only the
// ones owned by the user or shared with the user.
const allowedPosts = defineQueryWithContext<MyZeroContext>()(
    z.undefined(),
  ({ context: { userID } }) => {
    return zql.post.where(({cmp, exists, or}) => or(
      cmp('authorID', userID),
      exists('sharedWith', q => q.where('userID', userID)),
    ));
  },
);
```

#### Owned Rows or All if Admin

```ts
const allowedPosts = defineQueryWithContext<MyZeroContext>()(
  z.undefined(),
  ({ context: { userID, role } }) => {
    if (role === 'admin') {
      return zql.post;
    }
    return zql.post.where('authorID', userID);
  },
);
```

### Write Permissions

#### Enforce Ownership

```ts
// All created items are owned by the user who created them.
const createPost = defineMutatorWithContext<MyZeroContext>()(
  z.object({
    id: z.string(),
    title: z.string(),
    content: z.string(),
  }),
  (tx, { context: { userID }, args: { id, title, content } }) => {
    return zql.post.insert({
      id,
      title,
      content,
      authorID: userID,
    });
  },
);
```

#### Edit Owned Rows

```ts
const updatePost = defineMutatorWithContext<MyZeroContext>()(
  z.object({
    id: z.string(),
    content: z.string().optional(),
  }),
  (tx, { context: { userID }, args: { id, content } }) => {
    const prev = await tx.run(zql.post.where('id', id).one());
    if (!prev) {
      return;
    }
    if (prev.authorID !== userID) {
      throw new Error('Access denied');
    }
    return zql.post.update({
      id,
      content,
    });
  },
);
```

#### Edit Owned or Shared Rows

```ts
const updatePost = defineMutatorWithContext<MyZeroContext>()(
  z.object({
    id: z.string(),
    content: z.string().optional(),
  }),
  (tx, { context: { userID }, args: { id, content } }) => {
    const prev = await tx.run(
      zql.post
        .where('id', id)
        .related('sharedWith',
          q => q.where('userID', userID))
      .one()
    );
    if (!prev) {
      return;
    }
    if (prev.authorID !== userID &&
        prev.sharedWith.length === 0) {
      throw new Error('Access denied');
    }
    return zql.post.update({
      id,
      content,
    });
  },
);
```

#### Edit Owned or All if Admin

```ts
const updatePost = defineMutatorWithContext<MyZeroContext>()(
  z.object({
    id: z.string(),
    content: z.string().optional(),
  }),
  (tx, { context: { role, userID }, args: { id, content } }) => {
    const prev = await tx.run(zql.post.where('id', id).one());
    if (!prev) {
      return;
    }
    if (role !== 'admin' && prev.authorID !== userID) {
      throw new Error('Access denied');
    }
    return zql.post.update({
      id,
      content,
    });
  },
);
```
## Client-Side Data Storage

Zero stores client-side data in `IndexedDB` by default, but this is customizable with the `kvStore` parameter:

```ts
const zero = new Zero({
  // Store data in React Native's SQLite database
  // See https://zero.rocicorp.dev/docs/react-native
  kvStore: expoSQLiteStoreProvider(),
});

const zero = new Zero({
  // Store data in memory, it disappears on refresh
  kvStore: 'mem',
});
```

Because multiple users can share the same browser, Zero requires that you provide a `userID` parameter on construction:

```ts
const zero = new Zero({
  ...,
  userID: "user-123",
});
```

Zero stores each user's data in a different IndexedDB instance. This allows users to quickly switch between multiple users and accounts without resyncing.

<Note
  emoji="ðŸ§‘â€ðŸ«"
  type="warning"
  heading="`userID` is not a security boundary"
  slug="user-id-is-not-a-security-boundary"
>
  All users that have access to a browser profile have access to the same
  IndexedDB instances. There is nothing that Zero can do about this â€“ users can
  just open the folder where the data is stored and look inside it.
</Note>

If your application is unauthenticated, or if you don't need fast user switching, you can just set `userID` to a constant like `anon` or `guest`:

```ts
const zero = new Zero({
  ...,
  userID: "anon",
});
```

Alternately, if you have more than one set of Zero data per-user (i.e., for different apps in the same domain), you can additionally use the `storageKey` parameter:

```ts
const zero = new Zero({
  ...,
  userID: "user-123",
  storageKey: "my-app",
});
```

If specified, `storageKey` is concatenated along with `userID` and other internal Zero information to form a unique IndexedDB database name.

<ImageLightbox
  src="/images/auth/indexeddb.png"
  caption="Zero's IndexedDB databases are prefixed with 'rep' or 'replicache' because ... well because we haven't fixed this yet."
/>

## Logging Out

When a user logs out, you should consider what should happen to the synced data.

If you do nothing, the synced data will be left on the device. The next login will be a little faster because Zero doesn't have to resync that data from scratch. But also, the data will be left on the device indefinitely which could be undesirable for privacy and security.

If you instead want to clear data on logout, Zero provides the `dropAllDatabases` function:

```ts
import {dropAllDatabases} from '@rocicorp/zero';

// Returns an object with:
// - The names of the successfully dropped databases
// - Any errors encountered while dropping
const {dropped, errors} = await dropAllDatabases();
```
