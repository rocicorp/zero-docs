---
title: Add to Existing Project
---

This tutorial walks you through adding Zero to an existing web app in a few steps.

You can follow along using one of our starting templates, or adapt the instructions to your own TypeScript-based web app.

It should take about 15 minutes to complete. When you're done, you'll have the Zero sync engine integrated into your app.

## Integrate Zero

### Set Up Your Database

You'll need a local Postgres database for development. If you don't have a preferred method, we recommend using [Docker](https://www.docker.com/):

```bash
docker run -d --name zero-postgres \
  -e POSTGRES_PASSWORD="password" \
  -p 5432:5432 \
  postgres:16-alpine \
  # IMPORTANT: logical WAL level is required for Zero
  # to sync data to its SQLite replica
  postgres -c wal_level=logical
```

This will start a Postgres database running in the background.

<Note heading="Supported Postgres features">
  See [Supported Postgres Features](/docs/postgres-support) for more details on
  how Zero works with Postgres.
</Note>

### Install and Run Zero-Cache

Add Zero to your project:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
npm install @rocicorp/zero
```

```bash
pnpm add @rocicorp/zero
```

```bash
bun add @rocicorp/zero
```

```bash
yarn add @rocicorp/zero
```

</CodeGroup>

Start the development `zero-cache` by running the following command:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres" \
npx zero-cache-dev
```

```bash
ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres" \
pnpm exec zero-cache-dev
```

```bash
ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres" \
bunx zero-cache-dev
```

```bash
ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres" \
yarn zero-cache-dev
```

</CodeGroup>

Zero works by continuously replicating your upstream database into a SQLite _replica_.

Zero-cache runs client queries against the replica. If there are tables or columns that will **not** be queried by Zero clients ever, you can exclude them.

You can use the `zero-sqlite3` tool to explore `zero.db`. Try it out by connecting to Postgres and the Zero replica in two different terminals.
If you change something in Postgres, you'll see it immediately show up in the replica:

```
video
```

### Set Up Your Zero Schema

Zero uses information about your database schema to provide a type-safe query API in a shared `schema.ts` file.
If you use Drizzle or Prisma, you can generate your schema automatically. Otherwise, you can create the file manually.

<CodeGroup
  labels={[
    {
      text: 'Drizzle',
      sync: {orm: 'drizzle', pgClient: 'drizzle'},
    },
    {
      text: 'Prisma',
      sync: {orm: 'prisma', pgClient: 'prisma'},
    },
    {
      text: "Manual",
      sync: {orm: 'other', pgClient: 'other'},
    },
  ]}
>

<SyncedCode syncKey="pm" syncValues={['npm', 'pnpm', 'bun', 'yarn']}>

```bash
npx drizzle-zero generate
```

```bash
pnpm dlx drizzle-zero generate
```

```bash
bunx drizzle-zero generate
```

```bash
yarn dlx drizzle-zero generate
```

</SyncedCode>

<SyncedCode syncKey="pm" syncValues={['npm', 'pnpm', 'bun', 'yarn']}>

```bash
npm install @passionfroot/prisma-generator-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-generator-zero"
# }
npx prisma generate
```

```bash
pnpm add @passionfroot/prisma-generator-zero
# Add this to your prisma schema:
# generator zero {
#   provider       = "prisma-generator-zero"
# }
pnpx prisma generate
```

```bash
bun add @passionfroot/prisma-generator-zero
# Add this to your prisma schema:
# generator zero {
#   provider       = "prisma-generator-zero"
# }
bunx prisma generate
```

```bash
yarn add @passionfroot/prisma-generator-zero
# Add this to your prisma schema:
# generator zero {
#   provider       = "prisma-generator-zero"
# }
yarn prisma generate
```

</SyncedCode>

```ts
// shared/schema.ts
import {table, string, createSchema} from '@rocicorp/zero';

const user = table('user')
  .columns({
    id: string(),
    name: string(),
    // ... other columns ...
  })
  .primaryKey('id');

export const schema = createSchema({
  tables: [user],
});

// Register the schema for type safety
declare module '@rocicorp/zero' {
  interface Register {
    schema: typeof schema;
  }
}
```

</CodeGroup>

<Note heading="Introducing the sample schema">
  For the rest of this guide, we will reference a [sample
  schema](https://github.com/rocicorp/tutorial-tanstack-drizzle/blob/main/src/schema.ts)
  that models a Spotify-style music app. You can adapt these examples to your
  own data model.
</Note>

{/* TODO some language about schema incompatibility? */}
{/* TODO some language about sample data? psql? */}

{/* TODO some setup for module augmentation? less verbose types?? forking prisma generator?? */}

### Set Up the Zero Client

Zero has first-class support for React and SolidJS, and community support for Svelte and Vue.

There is also a low-level API you can use in any TypeScript-based project.

{/* TODO add some preamble for "BYOA" (Bring Your Own Auth) or cookies or whatever */}

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/react';
import {schema} from './shared/schema.ts';

function Root() {
  return (
    <ZeroProvider cacheURL="http://localhost:4848" schema={schema}>
      <App />
    </ZeroProvider>
  );
}

// mycomponent.tsx
import {useZero} from '@rocicorp/zero/react';

function MyComponent() {
  const zero = useZero();
  console.log('clientID', zero.clientID);
}
```

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/solid';
import {schema} from './shared/schema.ts';

function Root() {
  return (
    <ZeroProvider cacheURL="http://localhost:4848" schema={schema}>
      <App />
    </ZeroProvider>
  );
}

// mycomponent.tsx
import {useZero} from '@rocicorp/zero/solid';

function MyComponent() {
  const zero = useZero();
  console.log('clientID', zero().clientID);
}
```

```tsx
// zero.ts
import {Zero} from '@rocicorp/zero';
import {schema} from './shared/schema.ts';

const zero = new Zero({
  cacheURL: 'http://localhost:4848',
  schema,
});

console.log('clientID', zero.clientID);

export {zero};
```

</CodeGroup>

## Sync Data

### Define Query

Alright, let's sync some data!

In Zero, we do this with _queries_. Queries can be defined anywhere, but are conventionally found in a shared `queries.ts` file.

```tsx
// shared/queries.ts
import {defineQueries, defineQuery} from '@rocicorp/zero';
import {z} from 'zod';
import {zql} from './schema.ts';

export const queries = defineQueries({
  albums: {
    byArtist: defineQuery(
      z.object({artistID: z.string()}),
      ({args: {artistID}}) => {
        return zql.album.where('artistID', artistID);
      },
    ),
  },
});

// Register the queries for type safety
declare module '@rocicorp/zero' {
  interface Register {
    queries: typeof queries;
  }
}
```

A Zero _query_ is a function that returns ZQL (Zero Query Language) which describes the data to retrieve. You can think of a query like a stored procedure in other databases.

The arguments for a query are defined by a _validator_. Any library that implements [Standard Schema](https://standardschema.dev/) is supported, such as Zod, Valibot, Effect Schema, etc.

<Note heading="Why do we need validators?">
  Queries and mutators run on your API server, where you can't trust the
  client-provided inputs.
</Note>

Use `zql` from `schema.ts` to construct and return a ZQL query. ZQL is quite powerful and allows you to build
queries with filters, sorts, relationships, and more. See the [ZQL Reference](/docs/zql) for complete details.

```bash
animation
```

### Invoke Query

Querying for data is framework-specific. Most of the time, you will use a helper like `useQuery` that integrates into your framework's rendering model:

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// mycomponent.tsx
import {useQuery} from '@rocicorp/zero/react';
import {queries} from './shared/queries.ts';

function MyComponent() {
  const [albums] = useQuery(queries.albums.byArtist({artistID: 'artist_3'}));
  return albums.map(a => <div key={a.id}>{a.title}</div>);
}
```

```tsx
// mycomponent.tsx
import {useQuery} from '@rocicorp/zero/solid';
import {queries} from './shared/queries.ts';

function MyComponent() {
  const [albums] = useQuery(() =>
    queries.albums.byArtist({artistID: 'artist_3'}),
  );
  return albums().map(a => <div key={a.id}>{a.title}</div>);
}
```

```tsx
// albums.ts
import {zero} from './zero.ts';
import {queries} from './shared/queries.ts';

const albums = await zero.run(queries.albums.byArtist({artistID: 'artist_3'}));
console.log('albums', albums);
```

</CodeGroup>

<Note heading="What is this example doing?">
  We're querying the [sample
  schema](/docs/add-to-existing-project#set-up-your-zero-schema) for albums by
  the artist with ID `artist_3`.
</Note>

If you run your app now, you should see an error like:

```ts
Uncaught exception. Could not get ZQL for query `albums.byArtist` because no queries endpoint is specified.
```

Let's fix that.

### Implement Query Backend

Zero doesn't allow clients to run any arbitrary ZQL against zero-cache, for both security and performance.

Instead, Zero sends the name and arguments of the query to a _queries endpoint_ on your server.

Your server returns its own implementation of the requested query and calls it, returning the ZQL expression to zero-cache.

The queries endpoint can return the exact same ZQL that ran on the client, or it could be different â€“ it commonly includes additional clauses that enforce permissions.

<CodeGroup
  labels={[
    {
      text: 'Next.js',
      sync: {api: 'nextjs'},
    },
    {
      text: 'Hono',
      sync: {api: 'hono'},
    },
    {
      text: 'Express',
      sync: {api: 'express'},
    },
  ]}
>

```ts
// app/api/queries/route.ts
import {handleQueryRequest} from '@rocicorp/zero/server';
import {queries} from '../../shared/queries.ts';

export async function POST(req: Request) {
  const result = await handleQueryRequest(req, (name, args) => {
    const q = queries.get(name);
    return q(args);
  });

  return Response.json(result);
}
```

```ts
// api/app.ts
import {Hono} from 'hono';
import {handleQueryRequest} from '@rocicorp/zero/server';
import {queries} from '../shared/queries.ts';

const app = new Hono();

app.post('/api/queries', async c => {
  const result = await handleQueryRequest(c.req, (name, args) => {
    const q = queries.get(name);
    return q(args);
  });

  return c.json(result);
});
```

```ts
// api/app.ts
import express from 'express';
import {handleQueryRequest} from '@rocicorp/zero/server';
import {queries} from '../shared/queries.ts';

const app = express();

// Parse JSON body
app.use(express.json());

app.post('/api/queries', async (req, res, next) => {
  try {
    const result = await handleQueryRequest(req.body, (name, args) => {
      const q = queries.get(name);
      return q(args);
    });

    res.json(result);
  } catch (err) {
    next(err);
  }
});
```

</CodeGroup>

Stop and re-run zero-cache with the URL of the queries endpoint:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres" \
ZERO_QUERIES_URL="http://localhost:3000/api/queries" \
npx zero-cache-dev
```

```bash
ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres" \
ZERO_QUERIES_URL="http://localhost:3000/api/queries" \
pnpm exec zero-cache-dev
```

```bash
ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres" \
ZERO_QUERIES_URL="http://localhost:3000/api/queries" \
bunx zero-cache-dev
```

```bash
ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres" \
ZERO_QUERIES_URL="http://localhost:3000/api/queries" \
yarn zero-cache-dev
```

</CodeGroup>

Now if you reload the page, you will see data:

```ts
animation;
```

Zero queries update live, so if you edit data in Postgres directly, you will see it update in the Zero replica AND the UI:

```ts
animation;
```

### More about Queries

You now know the basics, but there are a few more important pieces you'll need to learn for your first real app:

- How authentication and permissions work.
- Preloading queries to create instantly responsive UI.

For these details and more, see Reading Data with Queries.

But for now, let's move on to writes!

## Mutate Data

### Define Mutators

Data is written in Zero apps using _mutators_.
Similar to queries, we use a shared `mutators.ts` file:

```tsx
// shared/mutators.ts
import {defineMutators, defineMutator} from '@rocicorp/zero';
import {zql} from './schema.ts';
import {z} from 'zod';

export const mutators = defineMutators({
  albums: {
    create: defineMutator(
      z.object({
        id: z.string(),
        artistID: z.string(),
        title: z.string(),
        year: z.number(),
      }),
      async ({tx, args: {id, artistID, title, year}}) => {
        await tx.mutate.album.insert({id, artistID, title, year});
      },
    ),
  },
});

// Register the mutators for type safety
declare module '@rocicorp/zero' {
  interface Register {
    mutators: typeof mutators;
  }
}
```

You can use the [CRUD-style API](/docs/mutators#writing-data) on `tx` to write data within your mutator.
You can also use `tx.run(q)` to run queries or ZQL expressions.

<Note type="warning" heading="Always await operations in mutators">
  Mutators almost always run in the same frame on the client, against local
  data. The reason mutators are marked `async` is because on the server, reading
  from the `tx` object goes over the network to Postgres. Also, in edge cases on
  the client, `tx.get()` can go to local storage (IndexedDB or SQLite).
</Note>

Unlike queries, you _must_ register your mutators with Zero before you can use them:

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/react';
import {mutators} from './shared/mutators.ts';
import {schema} from './shared/schema.ts';

function Root() {
  return (
    <ZeroProvider
      cacheURL="http://localhost:4848"
      schema={schema}
      mutators={mutators}
    >
      <App />
    </ZeroProvider>
  );
}
```

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/solid';
import {mutators} from './shared/mutators.ts';
import {schema} from './shared/schema.ts';

function Root() {
  return (
    <ZeroProvider
      cacheURL="http://localhost:4848"
      schema={schema}
      mutators={mutators}
    >
      <App />
    </ZeroProvider>
  );
}
```

```tsx
// zero.ts
import {Zero} from '@rocicorp/zero';
import {schema} from './shared/schema.ts';
import {mutators} from './shared/mutators.ts';

const zero = new Zero({
  cacheURL: 'http://localhost:4848',
  schema,
  mutators,
});

console.log('clientID', zero.clientID);

export {zero};
```

</CodeGroup>

### Invoke Mutators

You can now call mutators via `zero.mutate`:

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// mycomponent.tsx
import {useZero} from '@rocicorp/zero/react';
import {mutators} from './shared/mutators.ts';

function MyComponent() {
  const zero = useZero();

  const onClick = async () => {
    const album = {
      id: crypto.randomUUID(),
      artistID: 'artist_1',
      title: '',
      year: 2024,
    };
    const result = zero.mutate(mutators.albums.create(album));
    const clientResult = await result.client;

    if (clientResult.type === 'error') {
      console.error('Failed to create album', clientResult.error.message);
    } else {
      console.log('Album created!');
    }
  };

  return <button onClick={onClick}>Create Album</button>;
}
```

```tsx
// mycomponent.tsx
import {useQuery} from '@rocicorp/zero/solid';
import {mutators} from './shared/mutators.ts';

function MyComponent() {
  const zero = useZero();

  const onClick = async () => {
    const album = {
      id: crypto.randomUUID(),
      artistID: 'artist_1',
      title: '',
      year: 2024,
    };
    const result = zero().mutate(mutators.albums.create(album));
    const clientResult = await result.client;

    if (clientResult.type === 'error') {
      console.error('Failed to create album', clientResult.error.message);
    } else {
      console.log('Album created!');
    }
  };

  return <button onClick={onClick}>Create Album</button>;
}
```

```tsx
// albums.ts
import {zero} from './zero.ts';
import {mutators} from './shared/mutators.ts';

const album = {
  id: crypto.randomUUID(),
  artistID: 'artist_1',
  title: '',
  year: 2024,
};
const result = await zero.mutate(mutators.albums.create(album));
const clientResult = await result.client;

if (clientResult.type === 'error') {
  console.error('Failed to create album', clientResult.error.message);
} else {
  console.log('Album created!');
}
```

</CodeGroup>

If you run this app now, you should be able to see the UI update optimistically, but you'll also see an error in zero-cache:

```ts
Uncaught exception. Could not execution mutation `albums.create` because no mutate endpoint is specified.
```

This is because, like queries, we need to implement an endpoint in our API. Let's fix it!

### Implement Mutate Endpoint

Zero requires a _mutate endpoint_ which runs on your server and connects directly to your Postgres database.
Zero provides helpers to implement this easily.

You can use the Zero Postgres adapters to create a `dbProvider` instance:

<CodeGroup
  labels={[
    {
      text: 'Drizzle',
      sync: {pgClient: 'drizzle'},
    },
    {
      text: 'node-postgres',
      sync: {pgClient: 'node-postgres'},
    },
    {
      text: 'postgres.js',
      sync: {pgClient: 'postgres-js'},
    },
  ]}
>

```ts
// app/api/mutate/db-provider.ts
import {zeroDrizzle} from '@rocicorp/zero/server/adapters/drizzle';
import {schema} from '../../shared/schema.ts';

// pass a drizzle client instance. for example:
// const drizzleClient = drizzle(pool, { schema: drizzleSchema })
export const dbProvider = zeroDrizzle(schema, drizzleClient);

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface Register {
    dbProvider: typeof dbProvider;
  }
}
```

```ts
// app/api/mutate/db-provider.ts
import {zeroNodePg} from '@rocicorp/zero/server/adapters/pg';
import {Pool} from 'pg';
import {schema} from '../../shared/schema.ts';

const pool = new Pool({
  connectionString: process.env.ZERO_UPSTREAM_DB!,
});
export const dbProvider = zeroNodePg(schema, pool);

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface Register {
    dbProvider: typeof dbProvider;
  }
}
```

```ts
// app/api/mutate/db-provider.ts
import {zeroPostgresJS} from '@rocicorp/zero/server/adapters/postgresjs';
import postgres from 'postgres';
import {schema} from '../../shared/schema.ts';

const sql = postgres(process.env.ZERO_UPSTREAM_DB!);
export const dbProvider = zeroPostgresJS(schema, sql);

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface Register {
    dbProvider: typeof dbProvider;
  }
}
```

</CodeGroup>

Then, you can use the `dbProvider` to handle the mutate request:

<CodeGroup
  labels={[
    {
      text: 'Next.js',
      sync: {api: 'nextjs'},
    },
    {
      text: 'Hono',
      sync: {api: 'hono'},
    },
    {
      text: 'Express',
      sync: {api: 'express'},
    },
  ]}
>

```ts
// app/api/mutate/route.ts
import {handleMutateRequest} from '@rocicorp/zero/server';
import {mutators} from '../../shared/mutators.ts';
import {dbProvider} from './db-provider.ts';

export async function POST(req: Request) {
  const result = await handleMutateRequest(
    dbProvider,
    req,
    (transact, mutation) => {
      // Run any external API validation/checks before the db tx
      // if you throw here, the mutation will be rejected.

      const result = await transact(async tx => {
        const mutator = mutators.get(mutation.name);
        return mutator(mutation.args).run(tx); // TODO(0xcadams): no context here. correct??
      });

      // Run "fire and forget" work here, like sending
      // notifications/analytics. If you throw here,
      // it will be logged but won't change the mutation result.

      return result;
    },
  );

  return Response.json(result);
}
```

```ts
// api/app.ts
import {handleMutateRequest} from '@rocicorp/zero/server';
import {mutators} from '../shared/mutators.ts';
import {dbProvider} from './db-provider.ts';

app.post('/api/mutate', async c => {
  const result = await handleMutateRequest(
    dbProvider,
    c.req,
    (transact, mutation) => {
      // Run any external API validation/checks before the db tx
      // if you throw here, the mutation will be rejected.

      const result = await transact(async tx => {
        const mutator = mutators.get(mutation.name);
        return mutator(mutation.args).run(tx); // TODO(0xcadams): no context here. correct??
      });

      // Run "fire and forget" work here, like sending
      // notifications/analytics. If you throw here,
      // it will be logged but won't change the mutation result.

      return result;
    },
  );

  return c.json(result);
});
```

```ts
// api/app.ts
import {handleMutateRequest} from '@rocicorp/zero/server';
import {mutators} from '../shared/mutators.ts';
import {dbProvider} from './db-provider.ts';

app.post('/api/mutate', async (req, res, next) => {
  try {
    const result = await handleMutateRequest(
      dbProvider,
      req.body,
      (transact, mutation) => {
        // Run any external API validation/checks before the db tx
        // if you throw here, the mutation will be rejected.

        const result = await transact(async tx => {
          const mutator = mutators.get(mutation.name);
          return mutator(mutation.args).run(tx); // TODO(0xcadams): no context here. correct??
        });

        // Run "fire and forget" work here, like sending
        // notifications/analytics. If you throw here,
        // it will be logged but won't change the mutation result.

        return result;
      },
    );

    res.json(result);
  } catch (err) {
    next(err);
  }
});
```

</CodeGroup>

If you refresh the page, your mutation should work and sync to other clients:

```
video
```

### More about Mutators

Just as with queries, the separate server implementation of mutators extends elegantly to enable write permissions.
Zero also has built-in helpers to do work after a mutator runs on the server, like send notifications.

For these details and more, see Writing Data with Mutators.

## That's It

Congratulations! You now know the basics for building with Zero ðŸ¤¯.

Possible next steps:

- Learn about authentication and permissions
- See some samples of built-out Zero apps
- Learn how to deploy your app to production
- Learn the big picture design of Zero
