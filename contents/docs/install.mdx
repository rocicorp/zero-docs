---
title: Install Zero
---

This guide walks you through adding Zero to any TypeScript-based web app.

It should take about 10-15 minutes to complete. When you're done, you'll have Zero up and running and understand the core ideas of using Zero.

## Integrate Zero

### Set Up Your Database

You'll need a local Postgres database for development. If you don't have a preferred method, we recommend using [Docker](https://www.docker.com/):

```bash
docker run -d --name zero-postgres \
  -e POSTGRES_PASSWORD="password" \
  -p 5432:5432 \
  postgres:16-alpine \
  # IMPORTANT: logical WAL level is required for Zero
  # to sync data to its SQLite replica
  postgres -c wal_level=logical
```

This will start a Postgres database running in the background.

<Note heading="More Information">
  See [Connecting to Postgres](/docs/connecting-to-postgres)
  for more details on what Postgres features are required
  for Zero to work.
</Note>

### Install and Run Zero-Cache

Add Zero to your project:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
npm install @rocicorp/zero
```

```bash
pnpm add @rocicorp/zero

# Note: pnpm disables postinstall scripts by default for security.
# Either approve the build:
pnpm approve-builds

# Or add to package.json:
# "pnpm": {
#   "onlyBuiltDependencies": ["@rocicorp/zero-sqlite3"]
# }
```

```bash
bun add @rocicorp/zero

# Note: Bun disables postinstall scripts by default for security.
# Add to package.json:
# "trustedDependencies": ["@rocicorp/zero-sqlite3"]
```

```bash
yarn add @rocicorp/zero
```

</CodeGroup>

Start the development `zero-cache` by running the following command:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
npx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
pnpm exec zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
bunx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
yarn zero-cache-dev
```

</CodeGroup>

Zero works by continuously replicating your upstream database into a SQLite _replica_.

Zero-cache runs client queries against the replica. If there are tables or columns that will **not** be queried by Zero clients ever, you can exclude them.

You can use the [`zero-sqlite3`](/docs/debug/replication#inspecting) tool to explore `zero.db`. Try it out by connecting to Postgres and the Zero replica in two different terminals.
If you change something in Postgres, you'll see it immediately show up in the replica:

<Video
  src="/video/onboarding/zero-cache-sync.mp4"
  alt="Zero-cache syncing between Postgres and SQLite"
  animation
/>

### Set Up Your Zero Schema

Zero uses a file called `schema.ts` to provide a type-safe query API.

If you use Drizzle or Prisma, you can generate `schema.ts` automatically. Otherwise, you can create it manually.

<CodeGroup
  labels={[
    {
      text: 'Drizzle',
      sync: {orm: 'drizzle', pgClient: 'drizzle'},
    },
    {
      text: 'Prisma',
      sync: {orm: 'prisma', pgClient: 'prisma'},
    },
    {
      text: "Manual",
      sync: {orm: 'other', pgClient: 'other'},
    },
  ]}
>

<SyncedCode syncKey="pm" syncValues={['npm', 'pnpm', 'bun', 'yarn']}>

```bash
npm install -D drizzle-zero
npx drizzle-zero generate
```

```bash
pnpm add -D drizzle-zero
pnpm dlx drizzle-zero generate
```

```bash
bun add -D drizzle-zero
bunx drizzle-zero generate
```

```bash
yarn add -D drizzle-zero
yarn dlx drizzle-zero generate
```

</SyncedCode>

<SyncedCode syncKey="pm" syncValues={['npm', 'pnpm', 'bun', 'yarn']}>

```bash
npm install -D prisma-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-zero"
# }
npx prisma generate
```

```bash
pnpm add -D prisma-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-zero"
# }
pnpx prisma generate
```

```bash
bun add -D prisma-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-zero"
# }
bunx prisma generate
```

```bash
yarn add -D prisma-zero
# Add this to your prisma schema:
# generator zero {
#   provider = "prisma-zero"
# }
yarn prisma generate
```

</SyncedCode>

```ts
// zero/schema.ts
import {table, string, createSchema} from '@rocicorp/zero'

const user = table('user')
  .columns({
    id: string(),
    name: string()
    // ... other columns ...
  })
  .primaryKey('id')

// ... more tables and relationships ...
// See "Schema" page in left nav for complete schema API.

export const schema = createSchema({
  tables: [user]
})

// Register the schema for type safety
declare module '@rocicorp/zero' {
  interface DefaultTypes {
    schema: typeof schema
  }
}
```

</CodeGroup>

<Note heading="Having trouble using your own schema?">
  Zero has some restrictions on the [Postgres features it
  supports](/docs/postgres-support). You can continue this
  tutorial with [a sample schema and seed
  data](https://github.com/rocicorp/onboarding) to evaluate
  it.
</Note>

### Set Up the Zero Client

Zero has first-class support for React and SolidJS, and community support for Svelte and Vue.

There is also a low-level API you can use in any TypeScript-based project.

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/react'
import {schema} from './zero/schema.ts'

function Root() {
  return (
    <ZeroProvider
      cacheURL="http://localhost:4848"
      schema={schema}
    >
      <App />
    </ZeroProvider>
  )
}

// mycomponent.tsx
import {useZero} from '@rocicorp/zero/react'

function MyComponent() {
  const zero = useZero()
  console.log('clientID', zero.clientID)
}
```

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/solid'
import {schema} from './zero/schema.ts'

function Root() {
  return (
    <ZeroProvider
      cacheURL="http://localhost:4848"
      schema={schema}
    >
      <App />
    </ZeroProvider>
  )
}

// mycomponent.tsx
import {useZero} from '@rocicorp/zero/solid'

function MyComponent() {
  const zero = useZero()
  console.log('clientID', zero().clientID)
}
```

```tsx
// zero.ts
import {Zero} from '@rocicorp/zero'
import {schema} from './zero/schema.ts'

const zero = new Zero({
  cacheURL: 'http://localhost:4848',
  schema
})

console.log('clientID', zero.clientID)

export {zero}
```

</CodeGroup>

## Sync Data

### Define Query

Alright, let's sync some data!

In Zero, we do this with _queries_. Queries are conventionally found in a `queries.ts` file.
Here is an example of how queries are defined - you can adapt this to your own schema:

```tsx
// zero/queries.ts
import {defineQueries, defineQuery} from '@rocicorp/zero'
import {z} from 'zod'
import {zql} from './schema.ts'

export const queries = defineQueries({
  albums: {
    byArtist: defineQuery(
      z.object({artistID: z.string()}),
      ({args: {artistID}}) =>
        zql.albums
          .where('artistId', artistID)
          .orderBy('createdAt', 'asc')
          .limit(10)
          .related('artist', q => q.one())
    )
  }
})
```

Use `zql` from `schema.ts` to construct and return a ZQL query. ZQL is quite powerful and allows you to build
queries with filters, sorts, relationships, and more:

<Video
  src="/video/onboarding/onboarding-zql-autocomplete.mp4"
  alt="Code editor with ZQL autocomplete"
  animation
/>

See [queries](/doc/queries) for more information on defining queries.

### Invoke Query

Querying for data is framework-specific. Most of the time, you will use a helper like `useQuery` that integrates into your framework's rendering model:

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// mycomponent.tsx
import {useQuery} from '@rocicorp/zero/react'
import {queries} from './zero/queries.ts'

function MyComponent() {
  const [albums] = useQuery(
    queries.albums.byArtist({artistID: 'artist_1'})
  )
  return albums.map(a => <div key={a.id}>{a.title}</div>)
}
```

```tsx
// mycomponent.tsx
import {useQuery} from '@rocicorp/zero/solid'
import {queries} from './zero/queries.ts'

function MyComponent() {
  const [albums] = useQuery(() =>
    queries.albums.byArtist({artistID: 'artist_1'})
  )
  return albums().map(a => <div key={a.id}>{a.title}</div>)
}
```

```tsx
// albums.ts
import {zero} from './zero.ts'
import {queries} from './zero/queries.ts'

const albums = await zero.run(
  queries.albums.byArtist({artistID: 'artist_1'})
)
console.log('albums', albums)
```

</CodeGroup>

If you run your app now, you should see an error like:

```
Uncaught exception. Could not get ZQL for query `albumsByArtist` because no query endpoint is specified.
```

Let's fix that.

### Implement Query Backend

Zero doesn't allow clients to run any arbitrary ZQL against zero-cache, for both security and performance reasons.

Instead, Zero sends the name and arguments of the query to a _queries endpoint_ on your server that is responsible for transforming the named query into ZQL.

Zero provides utilities to make it easy to implement the queries endpoint in any full-stack framework:

<CodeGroup
  labels={[
    {
      text: 'Tanstack Start',
      sync: {api: 'tanstack'},
    },
    {
      text: 'Next.js',
      sync: {api: 'nextjs'},
    },
    {
      text: 'Solid Start',
      sync: {api: 'solid'},
    },
    {
      text: 'Hono',
      sync: {api: 'hono'},
    },
  ]}
>

```ts
// src/routes/api/query.ts
import {createFileRoute} from '@tanstack/react-router'
import {json} from '@tanstack/react-start'
import {handleQueryRequest} from '@rocicorp/zero/server'
import {mustGetQuery} from '@rocicorp/zero'
import {queries} from '../../zero/queries.ts'
import {schema} from '../../zero/schema.ts'

export const Route = createFileRoute('/api/query')({
  server: {
    handlers: {
      POST: async ({request}) => {
        const result = await handleQueryRequest(
          (name, args) => {
            const query = mustGetQuery(queries, name)
            return query.fn({args, ctx: {userId: 'anon'}})
          },
          schema,
          request
        )

        return json(result)
      }
    }
  }
})
```

```ts
// app/api/query/route.ts
import {handleQueryRequest} from '@rocicorp/zero/server'
import {mustGetQuery} from '@rocicorp/zero'
import {queries} from '../../zero/queries.ts'
import {schema} from '../../zero/schema.ts'

export async function POST(req: Request) {
  const result = await handleQueryRequest(
    (name, args) => {
      const query = mustGetQuery(queries, name)
      return query.fn({args, ctx: {userId: 'anon'}})
    },
    schema,
    req
  )

  return Response.json(result)
}
```

```ts
// src/routes/api/query.ts
import type {APIEvent} from '@solidjs/start/server'
import {handleQueryRequest} from '@rocicorp/zero/server'
import {mustGetQuery} from '@rocicorp/zero'
import {queries} from '../../zero/queries.ts'
import {schema} from '../../zero/schema.ts'

export async function POST(event: APIEvent) {
  const result = await handleQueryRequest(
    (name, args) => {
      const query = mustGetQuery(queries, name)
      return query.fn({args, ctx: {userId: 'anon'}})
    },
    schema,
    event.request
  )

  return new Response.json(result)
}
```

```ts
// api/app.ts
import {Hono} from 'hono'
import {handleQueryRequest} from '@rocicorp/zero/server'
import {mustGetQuery} from '@rocicorp/zero'
import {queries} from '../zero/queries.ts'
import {schema} from '../zero/schema.ts'

const app = new Hono()

app.post('/api/query', async c => {
  const result = await handleQueryRequest(
    (name, args) => {
      const query = mustGetQuery(queries, name)
      return query.fn({args, ctx: {userId: 'anon'}})
    },
    schema,
    c.req.raw
  )

  return c.json(result)
})
```

</CodeGroup>

Stop and re-run zero-cache with the URL of the queries endpoint:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERY_URL="http://localhost:3000/api/query"
npx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERY_URL="http://localhost:3000/api/query"
pnpm exec zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERY_URL="http://localhost:3000/api/query"
bunx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERY_URL="http://localhost:3000/api/query"
yarn zero-cache-dev
```

</CodeGroup>

If you reload the page, you will see data!
Zero queries update live, so if you edit data in Postgres directly, you will see it update in the Zero replica AND the UI:

<Video
  src="/video/onboarding/zero-cache-ui-sync.mp4"
  alt="Zero-cache syncing between Postgres and SQLite and UI"
  animation
/>

### More about Queries

You now know the basics, but there are a few more important pieces you'll need to learn for your first real app:

- [How authentication and permissions work](/docs/auth).
- [Preloading queries to create instantly responsive UI](/docs/queries#for-preloading).

For these details and more, see [Reading Data](/docs/queries).

But for now, let's move on to writes!

## Mutate Data

### Define Mutators

Data is written in Zero apps using _mutators_.
Similar to queries, we use a shared `mutators.ts` file:

```tsx
// zero/mutators.ts
import {defineMutators, defineMutator} from '@rocicorp/zero'
import {crud} from './schema.ts'
import {z} from 'zod'

export const mutators = defineMutators({
  albums: {
    create: defineMutator(
      z.object({
        id: z.string(),
        artistID: z.string(),
        title: z.string(),
        year: z.number(),
        createdAt: z.number()
      }),
      async ({args, tx, ctx: _ctx}) => {
        await tx.mutate(
          crud.albums.insert({
            id: args.id,
            artistId: args.artistID,
            title: args.title,
            releaseYear: args.year,
            createdAt: args.createdAt
          })
        )
      }
    )
  }
})
```

You can use the [CRUD-style API](/docs/crud) with `tx.mutate(crud.<table>.<method>)`
to write data within your mutator.
You can also use `tx.run(zql.<table>.<method>)` to run ZQL expressions.

<Note
  type="warning"
  heading="Always await operations in mutators"
>
  Mutators almost always run in the same frame on the
  client, against local data. The reason mutators are marked
  `async` is because on the server, reading from the `tx`
  object goes over the network to Postgres. Also, in edge
  cases on the client, reads and writes can go to local
  storage (IndexedDB or SQLite).
</Note>

Once you've defined your mutators, you must register them with Zero before you can use them:

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/react'
import {mutators} from './zero/mutators.ts'
import {schema} from './zero/schema.ts'

function Root() {
  return (
    <ZeroProvider
      cacheURL="http://localhost:4848"
      schema={schema}
      mutators={mutators}
    >
      <App />
    </ZeroProvider>
  )
}
```

```tsx
// root.tsx
import {ZeroProvider} from '@rocicorp/zero/solid'
import {mutators} from './zero/mutators.ts'
import {schema} from './zero/schema.ts'

function Root() {
  return (
    <ZeroProvider
      cacheURL="http://localhost:4848"
      schema={schema}
      mutators={mutators}
    >
      <App />
    </ZeroProvider>
  )
}
```

```tsx
// zero.ts
import {Zero} from '@rocicorp/zero'
import {schema} from './zero/schema.ts'
import {mutators} from './zero/mutators.ts'

const zero = new Zero({
  cacheURL: 'http://localhost:4848',
  schema,
  mutators
})

console.log('clientID', zero.clientID)

export {zero}
```

</CodeGroup>

### Invoke Mutators

You can now call mutators via `zero.mutate`:

<CodeGroup
  labels={[
    {
      text: 'React',
      sync: {client: 'react'},
    },
    {
      text: 'SolidJS',
      sync: {client: 'solidjs'},
    },
    {
      text: 'Typescript',
      sync: {client: 'typescript'},
    },
  ]}
>

```tsx
// mycomponent.tsx
import {useZero} from '@rocicorp/zero/react'
import {mutators} from './zero/mutators.ts'

function MyComponent() {
  const zero = useZero()

  const onClick = async () => {
    const result = zero.mutate(
      mutators.albums.create({
        id: 'album_6',
        artistID: 'artist_1',
        title: 'Please Please Me',
        year: 1963,
        createdAt: Date.now()
      })
    )

    const clientResult = await result.client

    if (clientResult.type === 'error') {
      console.error(
        'Failed to create album',
        clientResult.error.message
      )
    } else {
      console.log('Album created!')
    }
  }

  return <button onClick={onClick}>Create Album</button>
}
```

```tsx
// mycomponent.tsx
import {useZero} from '@rocicorp/zero/solid'
import {mutators} from './zero/mutators.ts'

function MyComponent() {
  const zero = useZero()

  const onClick = async () => {
    const result = zero().mutate(
      mutators.albums.create({
        id: 'album_6',
        artistID: 'artist_1',
        title: 'Please Please Me',
        year: 1963,
        createdAt: Date.now()
      })
    )
    const clientResult = await result.client

    if (clientResult.type === 'error') {
      console.error(
        'Failed to create album',
        clientResult.error.message
      )
    } else {
      console.log('Album created!')
    }
  }

  return <button onClick={onClick}>Create Album</button>
}
```

```tsx
// albums.ts
import {zero} from './zero.ts'
import {mutators} from './zero/mutators.ts'

const result = await zero.mutate(
  mutators.albums.create({
    id: 'album_6',
    artistID: 'artist_1',
    title: 'Please Please Me',
    year: 1963,
    createdAt: Date.now()
  })
)
const clientResult = await result.client

if (clientResult.type === 'error') {
  console.error(
    'Failed to create album',
    clientResult.error.message
  )
} else {
  console.log('Album created!')
}
```

</CodeGroup>

If you run this app now, you should be able to see the UI update optimistically, but you'll also see an error in zero-cache:

```ts
Uncaught exception. Could not execution mutation `albums.create` because no mutate endpoint is specified.
```

This is because, like queries, we need to implement an endpoint in our API. Let's fix it!

### Implement Mutate Endpoint

Zero requires a _mutate endpoint_ which runs on your server and connects directly to your Postgres database.
Zero provides helpers to implement this easily.

Use the Zero Postgres adapters to create a `dbProvider` instance:

<CodeGroup
  labels={[
    {
      text: 'Drizzle',
      sync: {pgClient: 'drizzle'},
    },
    {
      text: 'node-postgres',
      sync: {pgClient: 'node-postgres'},
    },
    {
      text: 'postgres.js',
      sync: {pgClient: 'postgres-js'},
    },
  ]}
>

```ts
// app/api/mutate/db-provider.ts
import {zeroDrizzle} from '@rocicorp/zero/server/adapters/drizzle'
import {schema} from '../../zero/schema.ts'

// pass a drizzle client instance. for example:
export const drizzleClient = drizzle(pool, {
  schema: drizzleSchema
})
export const dbProvider = zeroDrizzle(schema, drizzleClient)

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface DefaultTypes {
    dbProvider: typeof dbProvider
  }
}
```

```ts
// app/api/mutate/db-provider.ts
import {zeroNodePg} from '@rocicorp/zero/server/adapters/pg'
import {Pool} from 'pg'
import {schema} from '../../zero/schema.ts'

const pool = new Pool({
  connectionString: process.env.ZERO_UPSTREAM_DB!
})
export const dbProvider = zeroNodePg(schema, pool)

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface DefaultTypes {
    dbProvider: typeof dbProvider
  }
}
```

```ts
// app/api/mutate/db-provider.ts
import {zeroPostgresJS} from '@rocicorp/zero/server/adapters/postgresjs'
import postgres from 'postgres'
import {schema} from '../../zero/schema.ts'

const sql = postgres(process.env.ZERO_UPSTREAM_DB!)
export const dbProvider = zeroPostgresJS(schema, sql)

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface DefaultTypes {
    dbProvider: typeof dbProvider
  }
}
```

</CodeGroup>

Then, use the `dbProvider` to handle the mutate request:

<CodeGroup
  labels={[
    {
      text: 'Tanstack Start',
      sync: {api: 'tanstack'},
    },
    {
      text: 'Next.js',
      sync: {api: 'nextjs'},
    },
    {
      text: 'Solid Start',
      sync: {api: 'solid'},
    },
    {
      text: 'Hono',
      sync: {api: 'hono'},
    },
  ]}
>

```ts
// src/routes/api/mutate.ts
import {createFileRoute} from '@tanstack/react-router'
import {json} from '@tanstack/react-start'
import {handleMutateRequest} from '@rocicorp/zero/server'
import {mustGetMutator} from '@rocicorp/zero'
import {mutators} from '../../zero/mutators.ts'
import {dbProvider} from '../../db-provider.ts'

export const Route = createFileRoute('/api/mutate')({
  server: {
    handlers: {
      POST: async ({request}) => {
        const result = await handleMutateRequest(
          dbProvider,
          async (transact, mutation) => {
            const result = await transact(async tx => {
              const mutator = mustGetMutator(
                mutators,
                mutation.name
              )
              return mutator.fn({
                args: mutation.args,
                tx,
                ctx: {userId: 'anon'}
              })
            })

            return result
          },
          request
        )

        return json(result)
      }
    }
  }
})
```

```ts
// app/api/mutate/route.ts
import {handleMutateRequest} from '@rocicorp/zero/server'
import {mutators} from '../../zero/mutators.ts'
import {dbProvider} from '../../db-provider.ts'
import {mustGetMutator} from '@rocicorp/zero'

export async function POST(req: Request) {
  const result = await handleMutateRequest(
    dbProvider,
    async (transact, mutation) => {
      const result = await transact(async tx => {
        const mutator = mustGetMutator(
          mutators,
          mutation.name
        )
        return mutator.fn({
          args: mutation.args,
          tx,
          ctx: {userId: 'anon'}
        })
      })

      return result
    },
    req
  )

  return Response.json(result)
}
```

```ts
// src/routes/api/mutate.ts
import type {APIEvent} from '@solidjs/start/server'
import {handleMutateRequest} from '@rocicorp/zero/server'
import {mustGetMutator} from '@rocicorp/zero'
import {mutators} from '../../zero/mutators.ts'
import {dbProvider} from '../../db-provider.ts'

export async function POST(event: APIEvent) {
  const result = await handleMutateRequest(
    dbProvider,
    async (transact, mutation) => {
      const result = await transact(async tx => {
        const mutator = mustGetMutator(
          mutators,
          mutation.name
        )
        return mutator.fn({
          args: mutation.args,
          tx,
          ctx: {userId: 'anon'}
        })
      })

      return result
    },
    event.request
  )

  return new Response.json(result)
}
```

```ts
// api/app.ts
import {handleMutateRequest} from '@rocicorp/zero/server'
import {mustGetMutator} from '@rocicorp/zero'
import {mutators} from '../zero/mutators.ts'
import {dbProvider} from './db-provider.ts'

app.post('/api/mutate', async c => {
  const result = await handleMutateRequest(
    dbProvider,
    async (transact, mutation) => {
      const result = await transact(async tx => {
        const mutator = mustGetMutator(
          mutators,
          mutation.name
        )
        return mutator.fn({
          args: mutation.args,
          tx,
          ctx: {userId: 'anon'}
        })
      })

      return result
    },
    c.req.raw
  )

  return c.json(result)
})
```

</CodeGroup>

Restart zero-cache to tell it about this new endpoint:

<CodeGroup
  labels={[
    {text: 'npm', sync: {pm: 'npm'}},
    {text: 'pnpm', sync: {pm: 'pnpm'}},
    {text: 'bun', sync: {pm: 'bun'}},
    {text: 'yarn', sync: {pm: 'yarn'}},
  ]}
>

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERY_URL="http://localhost:3000/api/query"
export ZERO_MUTATE_URL="http://localhost:3000/api/mutate"
npx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERY_URL="http://localhost:3000/api/query"
export ZERO_MUTATE_URL="http://localhost:3000/api/mutate"
pnpm exec zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERY_URL="http://localhost:3000/api/query"
export ZERO_MUTATE_URL="http://localhost:3000/api/mutate"
bunx zero-cache-dev
```

```bash
export ZERO_UPSTREAM_DB="postgres://postgres:password@localhost:5432/postgres"
export ZERO_QUERY_URL="http://localhost:3000/api/query"
export ZERO_MUTATE_URL="http://localhost:3000/api/mutate"
yarn zero-cache-dev
```

</CodeGroup>

If you refresh the page, your mutation should commit to the database and sync to other clients:

<Video
  src="/video/onboarding/zero-cache-multiple-clients.mp4"
  alt="Zero syncing data between multiple clients"
  animation
/>

### More about Mutators

Just as with queries, the separate server implementation of mutators extends elegantly to enable write permissions.
Zero also has built-in helpers to do work after a mutator runs on the server, like send notifications.

For these details and more, see [Writing Data](/docs/mutators).

## That's It!

Congratulations! You now know the basics for building with Zero ðŸ¤¯.

Possible next steps:

- [Learn about authentication and permissions](/docs/auth)
- [See some samples of built-out Zero apps](/docs/samples)
- [Learn how to deploy your app to production](/docs/deployment)
