---
title: Add to Existing Project
---

Zero can be easily integrated into any existing JavaScript or TypeScript
project, whether you're using React, Vue, Svelte, Solid, or vanilla JavaScript.

## Prerequisites

- A PostgreSQL database with Write-Ahead Logging (WAL) enabled.

For database configuration details, see [Connecting to
Postgres](connecting-to-postgres).

## Installation

Install the Zero package:

```bash
npm install @rocicorp/zero
```

**Note:** If using [pnpm](https://pnpm.io) or [bun](https://bun.sh), you'll need
additional steps to install native binaries. See [Not using
npm?](quickstart#not-npm) for details.

## Environment Variables

Configure Zero by creating a `.env` file in your project root:

```bash
ZERO_UPSTREAM_DB="postgresql://user:password@127.0.0.1/postgres"
ZERO_REPLICA_FILE="/tmp/sync-replica.db"
ZERO_AUTH_SECRET="secretkey"
```

Update these values with your actual database connection details and desired
settings. See [configuration options](zero-cache-config) for more information.

## Starting the Server

Launch the Zero server using the included CLI tool:

```bash
npx zero-cache
```

The server runs on port 4848 by default. Verify it's working by opening
`http://localhost:4848` in your browser.

## Defining Your Schema

Create a schema that describes your data model as detailed in the [Zero schema
documentation](zero-schema).

Example:

```ts
// schema.ts
import {createSchema, table, string} from '@rocicorp/zero';

const message = table('message')
  .columns({
    id: string(),
    body: string(),
  })
  .primaryKey('id');

export const schema = createSchema({
  tables: [message],
});

export type Schema = typeof schema;
```

## Custom Mutators (Optional)

Initially, you may want to focus on read-only operations. Once you're ready, you
can define custom mutators. For a detailed guide, see [Custom
Mutators](custom-mutators).

For a comprehensive guide, see [Custom Mutators](custom-mutators).

Here's a simple example of a mutator that adds a message to the database (ensure
this matches your PostgreSQL schema):

```ts
// mutators.ts
import type {CustomMutatorDefs} from '@rocicorp/zero';
import type {Schema} from './schema.ts';

export const mutators = {
  message: {
    async create(tx, message: Message) {
      await tx.mutate.message.insert(message);
    },
  },
} as const satisfies CustomMutatorDefs<Schema>;
```

## Creating a Zero Instance

To create a Zero client instance:

```js
import {Zero} from '@rocicorp/zero';

const z = new Zero({
  userID: 'anon',
  server: 'http://localhost:4848',
  schema,
  // mutators, // Optional
});
```

For production, avoid hardcoding the server URL. Instead, use an environment
variable like `import.meta.env.VITE_PUBLIC_SERVER` or
`process.env.NEXT_PUBLIC_SERVER`.

### Framework Integration

#### React

In React, you can create a `new Zero(...)` instance and optionally use a
`ZeroProvider` context. For more details, see [Integrations React](react).

#### SolidJS

For SolidJS, use the `createZero` function:

```js
import {createZero} from '@rocicorp/zero/solid';

const z = createZero({
  // same options as the Zero constructor
});
```

Refer to [Integrations SolidJS](solidjs) for additional information.

#### Other Frameworks

For other frameworks, consult the [UI frameworks](community#ui-frameworks)
documentation.

## Server-Side Rendering (SSR)

Zero is not designed to run on the server. To prevent client code from executing
during server-side rendering, use the following approaches:

### Next.js

Add the `use client`
[directive](https://nextjs.org/docs/app/api-reference/directives/use-client) to
mark client-only code.

### SolidStart

Wrap components that use Zero with the
[`clientOnly`](https://docs.solidjs.com/solid-start/reference/client/client-only)
higher-order component.

The standard pattern for `clientOnly` uses dynamic imports, but note that this
(like [React's `lazy`](https://react.dev/reference/react/lazy)) works with any
function that returns a `Promise<{default: () => JSX.Element}>`. You don't need
to use code splitting if it's not desired.

### TanStack Start

Use [React's `lazy`](https://react.dev/reference/react/lazy) to dynamically load
Zero components. This approach also works in Next.js.

## Custom Mutators

To use [custom mutators](custom-mutators):

1. Define them in the `Zero` constructor.
2. Implement a push endpoint for server-side logic.

For local development, add this to your `.env` file:

```bash
ZERO_PUSH_URL="http://localhost:3000/api/push"
```

### PushProcessor

The push endpoint uses the `POST` method and can be implemented with the
`PushProcessor` class from `@rocicorp/zero/pg`. See the [push endpoint
documentation](custom-mutators#custom-push-implementation) for more details.

Create a `PushProcessor` instance:

```js
import {PushProcessor, connectionProvider} from '@rocicorp/zero/pg';
import postgres from 'postgres';
import {schema} from './schema.ts';

const processor = new PushProcessor(
  schema,
  connectionProvider(postgres(process.env.ZERO_UPSTREAM_DB)),
);
```

Then implement an API endpoint to handle `POST` requests. The implementation
varies by framework, but the general pattern remains consistent:

#### Next.js

Create an API route in `app/api/push/route.ts`:

```ts
export async function POST(request: Request) {
  const authData = await validateAuthorizationHeader(request.headers);
  const body = await request.json();
  const params = Object.fromEntries(new URL(request.url).searchParams);
  return await processor.process(createMutators(authData), params, body);
}
```

#### SolidStart

Create an API route in `src/routes/api/push.ts`:

```ts
export async function POST({params, request}: APIEvent) {
  const authData = await validateAuthorizationHeader(request.headers);
  const body = await request.json();
  return await processor.process(createMutators(authData), params, body);
}
```

#### TanStack Start

Create an API route in `src/routes/api/push.ts`:

```ts
export const APIRoute = createAPIFileRoute('/api/push')({
  POST: async ({request, params}) => {
    const authData = await validateAuthorizationHeader(request.headers);
    const body = await request.json();
    return json(
      await processor.process(createMutators(authData), params, body),
    );
  },
});
```

## Deployment

When deploying your application, ensure that all the environment variables
defined in your `.env` file are set in your production environment.

See [Deployment](deployment) for more information on deploying Zero cache.

For deploying your frontend application, refer to the documentation of your
chosen framework or hosting provider.
