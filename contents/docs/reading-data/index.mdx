---
title: Reading Data with ZQL
---

ZQL is Zero’s query language. 

Inspired by SQL, ZQL is expressed in TypeScript with heavy use of the builder pattern. If you have used [Drizzle](https://orm.drizzle.team/) or [Kysley](https://kysely.dev/), ZQL will feel familiar.

ZQL queries are composed of one or more *clauses* that are chained together into a *query*.

Unlike queries in classic databases, the result of a ZQL query is a *view* that updates automatically and efficiently as the underlying data changes. You can call a query’s `materialize()` method to get a view, but more typically you run queries via some framework-specific bindings. For example see `useQuery` for [React](react) or [SolidJS](solidjs).

## Select

ZQL queries start by selecting a table. There is no way to select a subset of columns; ZQL queries always return the entire row (modulo column permissions).

```tsx
const z = new Zero(...);

// Returns a query that selects all rows and columns from the issue table.
z.query.issue;
```

This is a design tradeoff that allows Zero to better reuse the row locally for future queries. This also makes it easier to share types between different parts of the code.

## Ordering

You can sort query results by adding an `orderBy` clause:

```tsx
z.query.issue.orderBy('created', 'desc');
```

Multiple `orderBy` clauses can be present, in which case the data is sorted by those clauses in order:

```tsx
// Order by priority descending. For any rows with same priority,
// then order by created desc.
z.query.issue.orderBy('priority', 'desc').orderBy('created', 'desc');
```

All queries in ZQL have a default final order of their primary key. Assuming the `issue` table has a primary key on the `id` column, then:

```tsx
// Actually means: z.query.issue.orderBy('id', 'asc');
z.query.issue;

// Actually means: z.query.issue.orderBy('priority', 'desc').orderBy('id', 'asc');
z.query.issue.orderBy('priority', 'desc');
```

## Limit

You can limit the number of rows to return with `limit()`:

```tsx
z.query.issue.orderBy('created', 'desc').limit(100);
```

## Paging

You can start the results at or after a particular row with `start()`:

```tsx
let start: IssueRow | undefined;
while (true) {
	let q = z.query.issue.orderBy('created', 'desc').limit(100);
	if (start) {
		q = q.start(start);
	}
	const batch = q.run();
	console.log("got batch", batch);

	if (batch.length < 100) {
		break;
	}
	start = batch[batch.length - 1];
}

```

By default `start()` is *exclusive* - it returns rows starting **after** the supplied reference row. This is what you usually want for paging. If you want *inclusive* results, you can do:

```tsx
z.query.issue.start(row, {inclusive: true});
```

## Uniqueness

If you want exactly zero or one results, use the `one()` clause. This causes ZQL to return `Row|undefined` rather than `Row[]`.

```tsx
const result = z.query.issue.where('id', 42).one();
if (!result) {
	console.error("not found");
}
```

`one()` overrides any `limit()` clause that is also present.

## Relationships

You can query related rows using *relationships* that are defined in your [Zero schema](/docs/zero-schema).

```tsx
// Get all issues and their related comments
z.query.issue.related('comments');
```

Relationships are returned as hierarchical data. In the above example, each row will have a `comments` field which is itself an array of the corresponding comments row.

You can fetch multiple relationships in a single query:

```tsx
z.query.issue
	.related('comments')
	.related('reactions')
	.related('assignees');
```

### Refining Relationships

By default all matching relationship rows are returned, but this can be refined. The `related` method accepts an optional second function which is itself a query.

```tsx
z.query.issue.related('comments',
	// It is common to use the 'q' shorthand variable for this parameter,
	// but it is a _comment_ query in particular here, exactly as if you
	// had done z.query.comment.
	q => q.orderBy('modified', 'desc').limit(100).start(lastSeenComment)
);
```

This *relationship query* can have all the same clauses that top-level queries can have.

### Nested Relationships

You can nest relationships arbitrarily:

```tsx
// Get all issues, first 100 comments for each (ordered by modified,desc),
// and for each comment all of its reactions.
z.query.issue.related(
	'comments', q => q.orderBy('modified', 'desc').limit(100).related(
		'reactions')
	)
);
```

## Where

You can filter a query with `where()`:

```tsx
z.query.issue.where('priority', '=', 'high');
```

The first parameter is always a column name from the table being queried. Intellisense will offer available options (sourced from your [Zero Schema](/docs/zero-schema)).

### Comparison Operators

Where supports the following comparison operators:

| Operator | Allowed Operand Types | Description |
| --- | --- | --- |
| `=` , `!=` | boolean, number, string | JS strict equal (===) semantics |
| `<` , `<=`, `>`, `>=`  | number | JS number compare semantics |
| `LIKE`, `NOT LIKE`, `ILIKE`, `NOT ILIKE`  | string | SQL-compatible `LIKE` / `ILIKE` |
| `IN` , `NOT IN` | boolean, number, string | RHS must be array. Returns true if rhs contains lhs by JS strict equals. |
| `IS` , `IS NOT` | boolean, number, string, json, null | Same as `=` but also works for `null` |

TypeScript will restrict you from using operators with types that don’t make sense – you can’t use `>` with `boolean` for example.

<Note type="note">
  If you don’t see the comparison operator you need, let us know, many are easy to add.
</Note>

### Equals is the Default Comparison Operator

Because comparing by `=` is so common, you can leave it out and `where` defaults to `=`.

```tsx
z.query.issue.where('priority', 'high');
```

### Comparing to `null`

As in SQL, ZQL’s `null` is not equal to itself (`null ≠ null`).

This is required to make join semantics work: if you’re joining `employee.orgID` on `org.id` you do **not** want an employee in no organization to match an org that hasn’t yet been assigned an ID.

When you purposely want to compare to `null` ZQL supports `IS` and `IS NOT` operators that work just like in SQL:

```tsx
// Find employees not in any org.
z.query.employee.where('orgID', 'IS', null);
```

TypeScript will prevent you from comparing to `null` with other operators.

### Compound Filters

The argument to `where` can also be a callback that returns a complex expression:

```tsx
// Get all issues that have priority 'critical' or else have both
// priority 'medium' and not more than 100 votes.
z.query.issue.where({cmp, and, or, not} =>
  or(
    cmp('priority', 'critical'),
    and(cmp('priority', 'medium'), not(cmp('numVotes', '>', 100))),
  ),
);
```

`cmp` is short for *compare* and works the same as `where` at the top-level except that it can’t be chained and it only accepts comparison operators (no relationship filters – see below).

Note that chaining `where()` is also a one-level `and`:

```tsx
// Find issues with priority 3 or higher, owned by aa
z.query.issue.where('priority', '>=', 3).where('owner', 'aa');
```

### Relationship Filters

Your filter can also test properties of relationships. Currently the only supported test is existence:

```tsx
// Find all orgs that have at least one employee
z.query.organization.whereExists('employees');
```

The argument to `whereExists` is a relationship, so just like other relationships it can be refined with a query:

```tsx
// Find all orgs that have at least one cool employee
z.query.organization.whereExists('employees',
	q => q.where('location', 'Hawaii'));
```

As with querying relationships, relationship filters can be arbitrarily nested:

```tsx
// Get all issues that have comments that have reactions
z.query.issue.whereExists('comments',
	q => q.whereExists('reactions'));
);
```

The `exists` helper is also provided which can be used with `and`, `or`, `cmp`, and `not` to build compound filters that check relationship existence:

```tsx
// Find issues that have at least one comment or are high priority
z.query.issue.where({cmp, or, exists} =>
  or(
    cmp('priority', 'high'),
    exists('comments'),
  ),
);
```

## Preloading Queries

See [Preloading](/docs/preloading).

## Running Queries Once

Usually subscribing to a query is what you want in a reactive UI but every so often running a query once is all that’s needed.

```tsx
const results = z.query.issue.where('foo', 'bar').run();
```

<Note type="note">
  Zero does not currently have a way to wait for authoritative results. Because of this, this feature will most likely be useful when the data you’re querying has already been preloaded. See also [Ability to wait for authoritative results](/docs/roadmap).
</Note>