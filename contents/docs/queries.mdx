---
title: Queries
description: Reading and Syncing Data
---

Queries are how you read and sync data with Zero.

Here's a simple example:


```ts
import { defineQueries, defineQuery } from '@rocicorp/zero'
import { zql } from './schema.ts'
import z from "zod"

export const queries = defineQueries({
  postsByAuthor: defineQuery(
    z.object({ authorID: z.string() }),
    ({ args: { authorID } }) =>
      zql.post.where('authorID', authorID),
  ),
})
```

## Architecture

A copy of each query exists on both the client and on your server:

<ImageLightbox
  src="/images/custom-queries/queries1.svg"
  className="invert dark:invert-0"
/>

Often the implementations will be the same, and you can just share their code. This is easy with full-stack frameworks like TanStack Start or Next.js.

But the implementations don't have to be the same, or even compute the same result. For example, the server can add extra filters to enforce permissions that the client query does not.

### Life of a Query

When a query is invoked, it initially runs on the client, against the client-side datastore. Any matching data is returned immediately and the user sees instant results.

<ImageLightbox
  src="/images/custom-queries/queries2.svg"
  caption="Client hydration"
  className="invert dark:invert-0"
/>

In the background, the name and arguments for the query are sent to zero-cache. Zero-cache calls the `queries` endpoint on your server to get the ZQL for the query. Your server looks up its implementation of the query, invokes it, and returns the resulting ZQL expression to zero-cache.

Zero-cache then runs this ZQL against the server-side data. The initial server result is sent back to the client and the client query updates in response.

<ImageLightbox
  src="/images/custom-queries/queries4.svg"
  caption="Server hydration"
  className="invert dark:invert-0"
/>

zero-cache receives updates from Postgres via logical replication. It updates affected queries and sends rows changes back to the client, which updates the client query, and the user sees the changes.

<ImageLightbox
  src="/images/custom-queries/queries6.svg"
  caption="Incremental update"
  className="invert dark:invert-0"
/>

## Parameters

The first argument to `defineQuery` is a *validator* that determines the query's parameters. We use [Zod](https://zod.dev/) in these examples, but you can use any validation library that implements [Standard Schema](https://standardschema.dev/).

Parameter validation is needed because Zero queries run on both the client and [on your server](#server-setup). In the server case, the parameters come from the client and are untrusted. These inputs are validated using the validator you provide.

Zero supports only one formal parameter for each query, but it can be of any type you want. The convention is to use an object with named fields for extensibility:

```ts
const searchPosts = defineQuery(
  z.object({
    title: z.string().optional(),
    authorID: z.string().optional(),
    isOpen: z.boolean().optional(),
  }),
  ({ args: { title, authorID, isOpen } }) => {
    let q = zql.post
    if (title !== undefined) {
      q = q.where('title', title)
    }
    if (authorID !== undefined) {
      q = q.where('authorID', authorID)
    }
    if (isOpen !== undefined) {
      q = q.where('isOpen', isOpen)
    }
    return q
  },
)
```

<Note emoji="üßë‚Äçüíª" heading="Queries are code">
Although queries must ultimately return a ZQL expression, they can use any code you want to compute that expression. It's common to use `if` statements and other control flow to build the ZQL expression based on the parameters.
</Note>

## Context

Query parameters are supplied by the client application and passed to the server automatically by Zero. This makes them unsuitable for credentials, since the user could modify them.

For this reason, Zero queries also support a [`context` object](/docs/auth#context).

Access your context with the `ctx` parameter to your query:

```ts
const myPostsQuery = defineQuery(
  ({ ctx: { userID } }) => {
    // Note: User cannot control context.userID, so this safely
    // restricts the query to the user's own posts.
    return zql.post
      .where('authorID', userID)
  },
)
```

## queries.ts

By convention, queries are listed in a central `queries.ts` file. This allows them to be easily used on both the client and server:

```ts
import { defineQueries, defineQuery } from '@rocicorp/zero'
import { zql } from './schema.ts'
import z from "zod"

export const queries = defineQueries({
  posts: {
    get: defineQuery(
      z.string(),
      id => zql.post.where('id', id)
    ),
    byAuthor: defineQuery(
      z.object({
        authorID: z.string(),
        includeDrafts: z.boolean().optional(),
      }),
      ({ args: { authorID, includeDrafts } }) => {
        let q = zql.post.where('authorID', authorID)
        if (!includeDrafts) {
          q = q.where('isDraft', false)
        }
        return q
      }
    ),
  }
})
```

You can use as many levels of nesting as you want to organize your queries.

As your application grows, you can move queries to different files to keep them organized:

```ts
// posts.ts
export const postQueries = {
  get: defineQuery(
    z.string(),
    id => zql.post.where('id', id)
  ),
  // ...
}

// users.ts
export const userQueries = {
  byRole: defineQuery(
    z.string(),
    role => zql.user.where('role', role)
  ),
  // ...
}

// queries.ts
import { postQueries } from './posts.ts'
import { userQueries } from './users.ts'

export const queries = defineQueries({
  posts: postQueries,
  users: userQueries,
})
```

<Note type="warning" emoji="‚ö†Ô∏è" heading="Use `defineQueries` only at top level">
`defineQueries` establishes the full name for each query (i.e., `posts.get`, `users.byRole`), which is later sent to the [server](#server-setup).

So this should only be used once at the top level of your `queries.ts` file.
</Note>

## Server Setup

In order for queries to sync, you must provide an implementation of the `query` endpoint on your server. `zero-cache` calls this endpoint to resolve each query to [ZQL](./zql) that it can run.

### Registering the Endpoint

Use [`ZERO_QUERY_URL`](./zero-cache-config#query-url) to tell `zero-cache` where to find your `query` implementation:

```bash
export ZERO_QUERY_URL="http://localhost:3000/api/zero/query"
npx zero-cache-dev
```

### Implementing the Endpoint

The `@rocicorp/zero` package provides the `handleQueryRequest` and `mustGetQuery` functions to make it easy to implement the endpoint.

For example, with [Hono](https://hono.dev):

```ts
import { mustGetQuery } from "@rocicorp/zero"
import { handleQueryRequest } from "@rocicorp/zero/server"
import { schema } from "schema.ts"
import { queries } from "queries.ts"

app.post("/api/zero/query", async (c) => {
  const userID = await authenticateUser(c.req.raw)
  const ctx = { userID }
  return await c.json(
    await handleQueryRequest(
      (name, args) => {
        const q = mustGetQuery(queries, name)
        return q.fn({ctx, args})
      },
      schema,
      c.req.raw
    )
  )
})
```

`handleQueryRequest` accepts a standard `Request` and returns a JSON object which can be serialized and returned by your server framework of choice.

`mustGetQuery` looks up the query in the registry and throws an error if not found.

The `query.fn` function is your query implementation wrapped in the validator you provided.

### Handling Errors

If the queries endpoint returns an HTTP or network error, `zero-cache` will be report it to the client using the `type` and `error` fields on the query details object:

```tsx
const [posts, details] = useQuery(
  queries.posts.byAuthorID('user123'))
if (details.type === 'error') {
  return <div>Error loading posts: {details.error.message}</div>
}
```

Or using the low-level API:

```ts
// Materialize a view of a query
const postsView = queries.posts.byAuthorID('user123').materialize()
postsView.addListener((posts, resultType, error) => {
  if (resultType === 'error') {
    console.error('Error loading posts', error)
  }
})
```

### Custom Query URL

By default, Zero sends queries to the URL specified in the `ZERO_QUERY_URL` parameter.

However you can customize this on a per-client basis. To do so, list multiple comma-separted URLs in the `ZERO_QUERY_URL` parameter:

```bash
ZERO_QUERY_URL='https://api.example.com/query,https://api.staging.example.com/query'
```

Then choose one of those URLs by passing it to `queryURL` on the `Zero` constructor:

```ts
const zero = new Zero({
  schema,
  queries,
  queryURL: 'https://api.staging.example.com/query',
})
```

### URL Patterns

The strings listed in `ZERO_QUERY_URL` can also be [`URLPatterns`](https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API):

```bash
ZERO_QUERY_URL="https://mybranch-*.preview.myapp.com/query"
```

This queries URL will allow clients to choose URLs like:
- `https://mybranch-aaa.preview.myapp.com/query` ‚úÖ
- `https://mybranch-bbb.preview.myapp.com/query` ‚úÖ

But rejects URLs like:
- `https://preview.myapp.com/query` ‚ùå (missing subdomain)
- `https://malicious.com/query` ‚ùå (different domain)
- `https://mybranch-123.preview.myapp.com/query/extra` ‚ùå (extra path)
- `https://mybranch-123.preview.myapp.com/other` ‚ùå (different path)

<Note emoji="ü•á" heading="Pro Tip (tm)">
Because URLPattern is a web standard, you can test them right in your browser:
  <img alt="URL Pattern"
    src="/images/mutators/url-pattern.png"/>
</Note>

For more information, see the [URLPattern docs](https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API).

## Running Queries

### Reactively

The most common way to use queries is with the `useQuery` reactive hooks from the [React](react) or [SolidJS](solid) bindings:

```tsx
import { useQuery } from '@rocicorp/zero/react'
import { queries } from 'zero/queries.ts'

function App() {
  const [posts] = useQuery(queries.posts.get('user123'))
  return <div>{posts.map(post =>
    <div key={post.id}>{post.title}</div>)}
  </div>
}
```

These functions integrate with the associated frameworks to automatically re-render the UI when a query changes.

### Manually

You can use `zero.materialize()` to run and subscribe to a query result outside of a UI framework:

```ts
import { queries } from 'zero/queries.ts'

const myView = zero.materialize(
  queries.posts.byAuthorID('user123')
)

for (let post of myView.data) {
  console.log(post.title)
}
```

The view is automatically kept up to date by Zero as the underlying data changes. You can add a listener to the view to be notified when the data changes:

```ts
myView.addListener((posts) => {
  console.log(posts)
})
```

### Once

You usually want to subscribe to a query in a reactive UI, but every so often you'll need to run a query just once. To do this, use `zero.run()`:

```tsx
const results = await zero.run(
  z.query.issues.byPriority('high')
)
```

By default, `run()` only returns results that are currently available on the client. That is, it returns the data that would be given for [`result.type === 'unknown'`](#completeness).

If you want to wait for the server to return results, pass `{type: 'complete'}` to `run`:

```tsx
const results = await z.query.issues.byPriority('high')
  .run({type: 'complete'})
```

### For Preloading

Almost all Zero apps will want to preload some data in order to maximize the feel of instantaneous UI transitions.

Because preload queries are often much larger than a screenful of UI, Zero provides a special `zero.preload()` method to avoid the overhead of materializing the result into JS objects:

```tsx
import { queries } from 'zero/queries.ts'

// Preload a large number of the inbox query results.
zero.preload(
  queries.issues.inbox({
    sort: 'created',
    sortDirection: 'desc',
    limit: 1000,
  })
)
```

## Query Caching

Queries can be either _active_ or _cached_. An active query is one that is currently being used by the application. Cached queries are not currently in use, but continue syncing in case they are needed again soon.

<ImageLightbox
  src="/images/reading-data/query-lifecycle.svg"
  className="invert dark:invert-0"
/>

Active queries are created one of four ways:

1. The app calls `q.materialize()` to get a `View`.
2. The app uses a framework binding like React's `useQuery(q)`.
3. The app calls [`preload()`](#preloading) to sync larger queries without a view.
4. The app calls `q.run()` to get a single result.

Active queries can be _deactivated_ according to how they were created:

1. For `materialize()` queries, the UI calls `destroy()` on the view.
2. For `useQuery()`, the UI unmounts the component (which calls `destroy()` under the covers).
3. For `preload()`, the UI calls `cleanup()` on the return value of `preload()`.
4. For `run()`, queries are automatically deactivated immediately after the result is returned.

Additionally when a Zero instance closes, all active queries are automatically deactivated. This also happens when the containing page or script is unloaded.

### TTLs

Each query has a `ttl` that controls how long it stays cached.

<Note emoji="üí°" heading="The TTL clock only ticks while Zero is running">
If the user closes all tabs for your app, Zero stops running and the time that elapses doesn't count toward any TTLs.

You do not need to account for such time when choosing a TTL ‚Äì you only need to account for time your app is running *without* a query.
</Note>

### TTL Defaults

In most cases, the default TTL should work well:

* `preload()` queries default to `ttl:'none'`, meaning they are not cached at all, and will stop syncing immediately when deactivated. But because `preload()` queries are typically registered at app startup and never shutdown, and [because the ttl clock only ticks while Zero is running](#the-ttl-clock-only-ticks-while-zero-is-running), this means that preload queries never get unregistered.
* Other queries have a default `ttl` of `5m` (five minutes).

### Setting Different TTLs

You can override the default TTL with the `ttl` parameter:

```ts
// With useQuery():
const [user] = useQuery(
    z.query.user.byID('id', userId),
    {ttl: '5m'})

// With preload():
z.query.user.byID('id', userId).preload(
    {ttl: '5m'})

// With run():
const user = await z.query.user.byID('id', userId).run(
    {ttl: '5m'})

// With materialize():
const view = z.query.user.byID('id', userId).materialize(
    {ttl: '5m'})
```

TTLs up to `10m` (ten minutes) are currently supported. The following formats are allowed:

| Format    | Meaning                                                   |
| --------- | --------------------------------------------------------- |
| `none`    | No caching. Query will immediately stop when deactivated. |
| `%ds`     | Number of seconds.                                        |
| `%dm`     | Number of minutes.                                        |

### Choosing a TTL

If you choose a different TTL, you should consider how likely it is that the query will be reused, and how far into the future this reuse will occur. Here are some guidelines to help you choose a TTL for common query types:

#### Preload Queries

These queries load the most commonly needed data for your app. They are typically larger, run with the `preload()` method, and stay running the entire time your app is running.

Because these queries run the entire time Zero runs, they do not need any TTL to keep them alive. And using a `ttl` for them is wasteful since when your app changes its preload query, it will end up running the old preload query *and* the new preload query, even though the app only cares about the new one.

**Recommendation:** `ttl: 'none'` *(the default for `preload()`)*.

#### Navigational Queries

These queries load data specific to a route. They are typically smaller and run with the `useQuery()` method. It is useful to cache them for a short time, so that they can be reactivated quickly if the user navigates back to the route.

**Recommendation:** `ttl: '5m'` *(the default for `useQuery()`)*.

#### Ephemeral Queries

These queries load data for a specific, short-lived user interaction and often come in large numbers (e.g., typeahead search).

The chance of any specific ephemeral query being reused is low, so the benefit of caching them is also low.

**Recommendation:** `useQuery(..., {ttl: 'none'})`)*.

### Why Zero TTLs are Short

Zero queries are not free.

Just as in any database, queries consume resources on both the client and server. Memory is used to keep metadata about the query, and disk storage is used to keep the query's current state.

We do drop this state after we haven't heard from a client for awhile, but this is only a partial improvement. If the client returns, we have to re-run the query to get the latest data.

This means that we do not actually *want* to keep queries active unless there is a good chance they will be needed again soon.

The default Zero TTL values might initially seem too short, but they are designed to work well with the way Zero's TTL clock works and strike a good balance between keeping queries alive long enough to be useful, while not keeping them alive so long that they consume resources unnecessarily.

## Custom Server Implementation

It is possible to implement the `ZERO_QUERY_URL` endpoint without using Zero's TypeScript libraries, or even in a different language entirely.

The endpoint receives a `POST` request with a JSON body of the form:

```ts
type QueriesRequestBody = {
    id: string
    name: string
    args: readonly ReadonlyJSONValue[]
}[]
```

And responds with:

```ts
type QueriesResponseBody = ({
    id: string
    name: string
    // See https://github.com/rocicorp/mono/blob/main/packages/zero-protocol/src/ast.ts
    ast: AST
} | {
    error: "app"
    id: string
    name: string
    details: ReadonlyJSONValue
} | {
    error: "zero"
    id: string
    name: string
    details: ReadonlyJSONValue
} | {
    error: "http"
    id: string
    name: string
    status: number
    details: ReadonlyJSONValue
})[]
```
