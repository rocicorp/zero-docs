---
title: Mutators
description: Writing Data
---

Mutators are how you write data with Zero. Here's a simple example:


```ts
import { defineMutators, defineMutator } from '@rocicorp/zero'
import { zql } from './schema.ts'
import z from "zod"

export const mutators = defineMutators({
  updateIssue: defineMutator(
    z.object({
      id: z.string(),
      title: z.string(),
    }),
    async ({tx, args: {id, title}}) => {
      if (title.length > 100) {
        throw new Error(`Title is too long`)
      }
      await tx.mutate.issue.update({id, title})
    }
  ),
})
```

## Architecture

A copy of each mutator exists on both the client and on your server:

<ImageLightbox
  src="/images/mutators/overview.png"
  className="invert dark:invert-0"
/>

Often the implementations will be the same, and you can just share their code. This is easy with full-stack frameworks like TanStack Start or Next.js.

But the implementations don't have to be the same, or even compute the same result. For example, the server can add extra checks to enforce permissions, or send notifications or interact with other systems.

### Server Authority

Zero is an example of a _server-authoritative_ sync engine. This means that the server mutator always takes precedence over the client mutator. The result from the client mutator is considered _speculative_ and is discarded as soon as the result from the server mutator is known. This is a very useful feature: it enables server-side validation, permissions, and other server-specific logic.

Imagine that you wanted to use an LLM to detect whether an issue update is spammy, rather than a simple length check. We can just add that to our server mutator:

```ts
const updateIssue = defineMutator(
  z.object({
    id: z.string(),
    title: z.string(),
  }),
  async ({tx, args: {id, title}}) => {
    const response = await llamaSession.prompt(
      `Is this title update likely spam?\n\n${title}\n\nResponse "yes" or "no"`,
    )
    if (/yes/i.test(response)) {
      throw new Error(`Title is likely spam`)
    }

    // delegate rest of implementation to client mutator
    await updateIssue(tx, {id, title})
  },
)
```

If the server detects that the mutation is spammy, the client will see the error message and the mutation will be rolled back. If the server mutator succeeds, the client mutator will be rolled back and the server result will be applied.

### Life of a Mutation

When a mutator is invoked, it initially runs on the client, against the client-side datastore. Any changes are immediately applied to open queries and the user sees the changes.

In the background, Zero sends a _mutation_ (a record of the mutator having run with certain arguments) to your server's push endpoint. Your push endpoint runs the [push protocol](#custom-push-implementation), executing the server-side mutator in a transaction against your database and recording the fact that the mutation ran. The `@rocicorp/zero` package contains utilities to make it easy to implement this endpoint in TypeScript.

The changes to the database are then replicated to `zero-cache` using logical replication. `zero-cache` calculates the updates to active queries and sends rows that have changed to each client. It also sends information about the mutations that have been applied to the database.

Clients receive row updates and apply them to their local cache. Any pending mutations which have been applied to the server have their local effects rolled back. Client-side queries are updated and the user sees the changes.

## Parameters

The first argument to `defineMutator` is a *validator* that determines the mutators's parameters. We use [Zod](https://zod.dev/) in these examples, but you can use any validation library that implements [Standard Schema](https://standardschema.dev/).

Parameter validation is needed because mutators run on both the client and [on your server](#server-setup). In the server case, the parameters come from the client and are untrusted. These inputs are validated using the validator you provide.

Zero supports only one formal parameter for each mutator, but it can be of any type you want. The convention is to use an object with named fields for extensibility.

## Context

Mutator parameters are supplied by the client application and passed to the server automatically by Zero. This makes them unsuitable for credentials, since the user could modify them.

For this reason, Zero mutators also support a [`context` object](/docs/auth#context).

Access your context with the `ctx` parameter to your mutator:

```ts
const createIssue =defineMutator(
  z.object({
    id: z.string(),
    title: z.string(),
    priority: z.number(),
  }),
  async ({
    tx,
    ctx: {userID},
    args: {id, title, priority}
  }) => {
    // Note: User cannot control ctx.userID, so this
    // enforces authorship of created issue.
    await tx.mutate.issue.insert({
      id,
      title,
      priority,
      authorID: userID,
    })
  },
)
```

## Writing Data

With a mutator, Zero provides a CRUD-style API to insert, update, and delete rows. Access the API with `tx.mutate.<tablename>`:

```tsx
const createIssue = defineMutator(
  async ({tx}) => {
    await tx.mutate.issue.create({
      // ...
    })
  },
)
```

### Insert

Create new records with `insert`:

```tsx
tx.mutate.user.insert({
  id: nanoid(),
  username: 'sam',
  language: 'js',
})
```

Optional fields can be set to `null` to explicitly set the new field to `null`. They can also be set to `undefined` to take the default value (which is often `null` but can also be some generated value server-side):

```tsx
// schema.ts
import {createTableSchema} from '@rocicorp/zero'

const userSchema = createTableSchema({
  tableName: 'user',
  columns: {
    id: {type: 'string'},
    name: {type: 'string'},
    language: {type: 'string', optional: true},
  },
  primaryKey: ['id'],
  relationships: {},
})

// app.tsx

// Sets language to `null` specifically
tx.mutate.user.insert({
  id: nanoid(),
  username: 'sam',
  language: null,
})

// Sets language to the default server-side value. Could be null, or some
// generated or constant default value too.
tx.mutate.user.insert({
  id: nanoid(),
  username: 'sam',
})

// Same as above
tx.mutate.user.insert({
  id: nanoid(),
  username: 'sam',
  language: undefined,
})
```

### Upsert

Create new records or update existing ones with `upsert`:

```tsx
tx.mutate.user.upsert({
  id: samID,
  username: 'sam',
  language: 'ts',
})
```

`upsert` supports the same `null` / `undefined` semantics for optional fields that `insert` does (see above).

### Update

Update an existing record. Does nothing if the specified record (by PK) does not exist.

You can pass a partial, leaving fields out that you donâ€™t want to change. For example here we leave the username the same:

```tsx
// Leaves username field to previous value.
tx.mutate.user.update({
  id: samID,
  language: 'golang',
})

// Same as above
tx.mutate.user.update({
  id: samID,
  username: undefined,
  language: 'haskell',
})

// Reset language field to `null`
tx.mutate.user.update({
  id: samID,
  language: null,
})
```

### Delete

Delete an existing record. Does nothing if specified record does not exist.

```tsx
tx.mutate.user.delete({
  id: samID,
})
```

## Reading Data

You can read data within a mutator by passing [ZQL](./reading-data) to `tx.run`:

```ts
const updateIssue = defineMutator(
  z.object({
    id: z.string(),
    title: z.string().optional(),
    priority: z.number().optional(),
  }),
  async ({tx, args: {id, title, priority}}) => {
    const issue = await tx.run(zql.issue.where('id', id).one())
    if (!issue) {
      throw new Error(`Issue not found`)
    }
    if (issue.priority !== priority) {
      throw new Error(`Priority mismatch`)
    }
    return issue
  },
)
```

You have the full power of ZQL at your disposal, including relationships, filters, ordering, and limits.

Reads and writes within a mutator are transactional, meaning that the datastore is guaranteed to not change while your mutator is running. And if the mutator throws, the entire mutation is rolled back.

<Note type="note" heading="Reading in Mutators is Always Local">
Unlike `z.run()`, there is no `type` parameter that can be used to wait for server results inside mutators.

This is because waiting for server results in mutators makes no sense â€“ it would defeat the purpose of running optimistically to begin with.

When a mutator runs on the client (`tx.location === "client"`), ZQL reads only return data already cached on the client. When mutators run on the server (`tx.location === "server"`), ZQL reads always return all data.
</Note>

## mutators.ts

By convention, mutators are listed in a central `mutators.ts` file. This allows them to be easily used on both the client and server:

```ts
import { defineMutators, defineMutator } from '@rocicorp/zero'
import { zql } from './schema.ts'
import z from "zod"

export const mutators = defineMutators({
  posts: {
    create: defineMutator(
      z.object({
        id: z.string(),
        title: z.string(),
        priority: z.number(),
      }),
      async (
        {tx, context: {userID}, args: {id, title, priority}}
      ) => {
        await tx.mutate.post.insert({
          id,
          title,
          priority,
          authorID: userID,
        })
      },
    ),
    update: defineMutator(
      z.object({
        id: z.string(),
        title: z.string().optional(),
        priority: z.number().optional(),
      }),
      async ({tx, context: {userID}, args: {id, title, priority}}) => {
        const prev = await tx.run(zql.post.where('id', id).one())
        if (!prev) {
          throw new Error(`Post not found`)
        }
        if (prev.authorID !== userID) {
          throw new Error(`Access denied`)
        }
        await tx.mutate.post.update({id, title, priority, authorID: userID})
      },
    ),
  } as const
}
```

You can use as many levels of nesting as you want to organize your queries.

As your application grows, you can move queries to different files to keep them organized:

```ts
// posts.ts
export const postMutators = {
  create: defineMutator(
    z.object({
      id: z.string(),
      title: z.string(),
    }),
    async (
      {tx, context: {userID}, args: {id, title}}
    ) => {
      await tx.mutate.post.insert({
        id,
        title,
        authorID: userID,
      })
    },
  ),
}

// user.ts
export const userMutators = {
  updateRole: defineMutator(
    z.object({
      role: z.string(),
    }),
    async ({tx, ctx: {userID}, args: {role}}) => {
      await tx.mutate.user.update({id: userID, role})
    },
  ),
}

// mutators.ts
import {postMutators} from 'zero/mutators/posts.ts'
import {userMutators} from 'zero/mutators/users.ts'

export const mutators = defineMutators{{ 
  posts: postMutators,
  users: userMutators,
})
```

<Note type="warning" emoji="âš ï¸" heading="Use `defineMutators` at top level only">
`defineMutators` establishes the full name for each mutator (i.e., `posts.create`, `users.updateRole`), which is later sent to the [server](#server-setup).

So this should only be used once at the top level of your `mutators.ts` file.
</Note>

## Registration

Before you can use your mutators, you need to register them with Zero.

In React or SolidJS, you'll do this by passing the `mutators` object to the `ZeroProvider` component:

```tsx
import { ZeroProvider } from '@rocicorp/zero/react'
import { mutators } from 'zero/mutators.ts'

<ZeroProvider mutators={mutators}>
  <App />
</ZeroProvider>
```

If you use the `Zero` class directly, you can pass the `mutators` object to the `Zero` constructor:

```ts
import { Zero } from '@rocicorp/zero'
import { mutators } from 'zero/mutators.ts'

const zero = new Zero({
  mutators,
})
```

<Note emoji="ðŸŒˆ" heading="The more you know">
Mutators need to be registered with Zero because Zero calls them during sync for conflict resolution.
</Note>

## Invoking Mutators

Once you have registered your mutators, you can call them through `zero.mutate`:

```ts
zero.mutate.issue.update({
  id: 'issue-123',
  title: 'New title',
})
```

## Waiting for Mutator Result

We typically recommend that you "fire and forget" mutators.

Optimistic mutations make sense when the common case is that a mutation succeeds. If a mutation frequently fails, then showing the user an optimistic result doesn't make sense, because it will likely be wrong.

That said there are cases where it is useful to know when a write succeeded on either the client or server.

One example is if you need to read a row directly after writing it. Zero's local writes are very fast (almost always < 1 frame), but because Zero is backed by IndexedDB, writes are still _technically_ asynchronous and reads directly after a write may not return the new data.

You can use the `.client` promise in this case to wait for a write to complete on the client side:

```ts
try {
  const write = zero.mutate.issue.insert({
    id: 'issue-123',
    title: 'New title',
  })

  // issue-123 not guaranteed to be present here. read1 may be undefined.
  const read1 = await zero.query.issue.byId('issue-123').one()

  // Await client write â€“ almost always less than 1 frame, and same
  // macrotask, so no browser paint will occur here.
  await write.client

  // issue-123 definitely can be read now.
  const read2 = await zero.query.issue.byId('issue-123').one()
} catch (e) {
  console.error('Mutator failed on client', e)
}
```

You can also wait for the server write to succeed:

```ts
try {
  const write = zero.mutate.issue.insert({
    id: 'issue-123',
    title: 'New title',
  })

  await write.client

  // optimistic write guaranteed to be present here, but not
  // server write.
  const read1 = await zero.query.issue.byId('issue-123').one()

  // Await server write â€“ this involves a round-trip.
  await write.server

  // issue-123 is written to server and any results are
  // synced to this client.
  // read2 could potentially be undefined here, for example if the
  // server mutator rejected the write.
  const read2 = await zero.query.issue.byId('issue-123').one()
} catch (e) {
  console.error('Mutator failed on client or server', e)
}
```

If the client-side mutator fails, the `.server` promise is also rejected with the same error. You don't have to listen to both promises, the server promise covers both cases.

<Note heading="Returning data from mutators" slug="returning-data">
  There is not yet a way to return data from mutators in the success case â€“ the type of `.client` and `.server` is always `Promise<void>`. [Let us know](https://discord.rocicorp.dev/) if you need this.
</Note>

## Server Setup

In order for mutations to sync, you must provide an implementation of the `mutate` endpoint on your server. `zero-cache` calls this endpoint to process each mutation.

### Registering the Endpoint

Use [`ZERO_MUTATE_URL`](./zero-cache-config#mutate-url) to tell `zero-cache` where to find your `mutate` implementation:

```bash
export ZERO_MUTATE_URL="http://localhost:3000/api/zero/mutate"
npx zero-cache-dev
```

### Implementing the Endpoint

The `@rocicorp/zero` package provides the `handleMutationRequest`, `mutatorByName`, and `withValidation` functions to make it easy to implement the endpoint.

For example, with [Hono](https://hono.dev):

```ts
import { withValidation, getMutation, ReadonlyJSONValue } from "@rocicorp/zero"
import { handleMutationRequest } from "@rocicorp/zero/server"
import { schema } from "schema.ts"
import { mutators } from "mutators.ts"

app.post("/mutate", async (c) => {
  const userID = await authenticateUser(c.req.raw)
  const context = { userID }
  return await c.json(
    await handleMutationRequest(
      transact =>
        transact(dbProvider, (tx, name, args) =>
          getMutation(mutators, name)(tx, {context, args}),
        ),
      c.req.raw
    )
  )
})
```

<Note heading="Using a different bindings library">
Zero includes several built-in database adapters. You can also easily create your own. See [ZQL on the Server](zql-on-the-server) for more information.
</Note>

`handleMutationRequest` accepts a standard `Request` and returns a JSON object which can be serialized and returned by your server framework of choice.

### Handling Errors

The `handleMutationRequest` function skips any mutations that throw:

```ts
app.post('/mutate', async c => {
  const result = await handleMutationRequest(
    transact =>
      transact(dbProvider, (tx, name, args) =>
          // The mutation is skipped and the next mutation runs as normal.
          throw new Error('bonk')
      ),
    c.req.raw
  )
  return await c.json(result)
})
```

`handleMutationRequest` catches such errors and turns them into a structured response that gets sent back to the client. You can [recover the errors](#waiting-for-mutator-result) and show UI if you want.

It is also of course possible for the entire push endpoint to return an HTTP error, or to not reply at all:

```ts
app.post('/mutate', async c => {
  // This will cause the client to resend all queued mutations.
  throw new Error('zonk')
})
```

If Zero receives any response from the mutate endpoint other than HTTP 200, 401, or 403, it will disconnect, wait a few moments, reconnect, and then retry all unprocessed mutations.

If Zero receives HTTP 401 or 403, the client [refreshes the `auth` token](./auth#auth-failure-and-refresh) if possible, then retries all queued mutations.

If you want a different behavior, it is possible to [implement the mutate endpoint](#custom-push-implementation) yourself and handle errors differently.

### Custom Mutate URL

By default, Zero sends mutations to the URL specified in the `ZERO_MUTATE_URL` parameter.

However you can customize this on a per-client basis. To do so, list multiple comma-separted URLs in the `ZERO_MUTATE_URL` parameter:

```bash
ZERO_MUTATE_URL='https://api.example.com/mutate,https://api.staging.example.com/mutate'
```

Then choose one of those URLs by passing it to `mutateURL` on the `Zero` constructor:

```ts
const zero = new Zero({
  schema,
  mutators,
  mutateURL: 'https://api.staging.example.com/mutate',
})
```

### URL Patterns

The strings listed in `ZERO_MUTATE_URL` can also be [`URLPatterns`](https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API):

```bash
ZERO_MUTATE_URL="https://mybranch-*.preview.myapp.com/mutate"
```

For more information, see the [URLPattern section of the Queries docs](/docs/queries#url-patterns). It works the same way for mutations.

### Server-Specific Code

To implement server-specific code, just run different mutators in your mutate endpoint!

An approach we like is to create a separate `server-mutators.ts` file that wraps the shared mutators:

```ts
// server-mutators.ts
import { defineMutatorWithContext } from '@rocicorp/zero'
import { Schema, zql } from 'schema.ts'
import z from "zod"
import { mutators as sharedMutators } from 'mutators.ts'

export const serverMutators = {
  ... sharedMutators,
  posts: {
    ... sharedMutators.posts,
    update: defineMutatorWithContext<MyZeroContext>()(
      z.object({
        id: z.string(),
        title: z.string().optional(),
        priority: z.number().optional(),
      }),
      async (
          tx: Transaction<Schema>,
          {context: {userID}, args: {id, title, priority}}) => {
        // Run the shared mutator first.
        await sharedMutators.posts.update(
          tx,
          context: {context, args},
        )

        // Record a history of this operation happening in an audit log table.
        await tx.mutate.auditLog.insert({
          issueId: id,
          action: 'update-title',
          timestamp: Date.getTime(),
        })
      },
    ),
  } as const
}
```

For simple things, we also expose a `location` field on the transaction object that you can use to branch your code:

```ts
const myMutator = defineMutator(
  z.undefined(),
  async (tx) => {
    if (tx.location === 'client') {
      // Client-side code
    } else {
      // Server-side code
    }
  },
)
```

### Permissions

Because mutators are just normal TypeScript functions that run server-side, there is no need for a special permissions system. You can implement whatever permission checks you want using plain TypeScript code.

See [Permissions](/docs/auth#permissions) for more information.

### Dropping Down to Raw SQL

The `ServerTransaction` interface has a `dbTransaction` property that exposes the underlying database connection. This allows you to run raw SQL queries directly against the database.

This is useful for complex queries, or for using Postgres features that Zero doesn't support yet:

```ts
const markAllAsRead = defineMutator(
  z.object({
    userId: z.string(),
  }),
  async (tx, {userId}) => {
  // shared stuff ...

  if (tx.location === 'server') {
    // `tx` is now narrowed to `ServerTransaction`.
    // Do special server-only stuff with raw SQL.
    await tx.dbTransaction.query(
      `
      UPDATE notification
      SET read = true
      WHERE user_id = $1
    `,
      [userId],
    )
  }
})
```

See [ZQL on the Server](/docs/zql-on-the-server) for more information.

### Notifications and Async Work

It is bad practice to hold open database transactions while talking over the network, for example to send notifications. Instead, you should let the db transaction commit and do the work asynchronously.

To do this, you can do your async work after closing the transaction inside `handleMutationRequest`:

```ts
// server-mutators.ts
import { defineMutator } from '@rocicorp/zero'
import { Schema, zql } from 'schema.ts'
import z from "zod"

export const mutators = {
  issue: {
    update: defineMutator(
      z.object({
        id: z.string(),
        title: z.string(),
      }),
      async (tx, {id, title}) => {
        await tx.mutate.issue.update({id, title})
        await sendEmailToSubscribers(id)
      },
    ),
  } as const,
}
```

Then in your push handler:

```ts
app.post('/push', async c => {
  const asyncTasks: Array<() => Promise<void>> = []
  const result = await processor.process(
    createMutators(authData, asyncTasks),
    c.req.query(),
    await c.req.json(),
  )

  await Promise.all(asyncTasks.map(task => task()))
  return await c.json(result)
})
```

### Custom Push Implementation

You can manually implement the push protocol in any programming language.

This will be documented in the future, but you can refer to the [PushProcessor](https://github.com/rocicorp/mono/blob/1a3741fbdad6dbdd56aa1f48cc2cc83938a61b16/packages/zero-pg/src/web.ts#L33) source code for an example for now.

