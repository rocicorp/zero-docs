---
title: Read Permissions
---

Permissions are expressed using [ZQL](reading-data) and run automatically with every read.

Permissions are currently row based. Zero will eventually also have column permissions.

## Defining Permissions

Permissions are defined in [`schema.ts`](/docs/zero-schema) using the `definePermissions` function.

Here's an example of limiting reads to members of an organization:

```ts
// The decoded value of your JWT.
type AuthData = {
  // The logged-in user.
  sub: string;
};

export const permissions = definePermissions<AuthData, Schema>(schema, () => {
  // Checks if the user exists in a related organization
  const allowIfInOrganization = (
    authData: AuthData,
    eb: ExpressionBuilder<Schema, 'issue'>,
  ) =>
    eb.exists('organization', q =>
      q.whereExists('user', q => q.where('id', authData.sub)),
    );

  return {
    issue: {
      row: {
        select: [allowIfInOrganization],
      },
    },
  } satisfies PermissionsConfig<AuthData, Schema>;
});
```

`definePermission` returns a _policy_ object for each table in the schema.

### Access is Denied by Default

If you don't specify any rules for a table, it is denied by default. This is an important safety feature that helps ensure data isn't accidentally exposed.

To enable full access to a select operation (i.e., during development) use the `ANYONE_CAN` helper:

```ts
import {ANYONE_CAN} from '@rocicorp/zero';

const permissions = definePermissions<AuthData, Schema>(schema, () => {
  return {
    issue: {
      row: {
        select: ANYONE_CAN,
      },
    },
    // Other tables are denied by default.
  } satisfies PermissionsConfig<AuthData, Schema>;
});
```

## Evaluating Permissions

Zero permissions are "compiled" into a JSON-based format at build-time. This file is stored in the `{ZERO_APP_ID}.permissions` table of your upstream database. Like other tables, it replicates live down to `zero-cache`. `zero-cache` then parses this file, and applies the encoded rules to every read operation.

<Note type="warning" slug="rule-compilation-is-dumb">
The compilation process is very simple-minded (read: dumb). Despite looking like normal TypeScript functions that receive an `AuthData` parameter, rule functions are not actually invoked at runtime. Instead, they are invoked with a "placeholder" `AuthData` at build time. We track which fields of this placeholder are accessed and construct a ZQL expression that accesses the right field of `AuthData` at runtime.

The end result is that you can't really use most features of JS in these rules. Specifically you cannot:

- Iterate over properties or array elements in the auth token
- Use any JS features beyond property access of `AuthData`
- Use any conditional or global state

Basically only property access is allowed. This is really confusing and we're working on a better solution.

</Note>

## Deploying Permissions

During development, permissions are compiled and uploaded to your database completely automatically as part of the `zero-cache-dev` script.

For production, you need to call `npx zero-deploy-permissions` within your app to update the permissions in the production database whenever they change. You would typically do this as part of your normal schema migration or CI process. For example, the SST deployment script for [zbugs](/docs/samples#zbugs) looks like this:

```ts
new command.local.Command(
  'zero-deploy-permissions',
  {
    create: `npx zero-deploy-permissions -p ../../src/schema.ts`,
    // Run the Command on every deploy ...
    triggers: [Date.now()],
    environment: {
      ZERO_UPSTREAM_DB: commonEnv.ZERO_UPSTREAM_DB,
      // If the application has a non-default App ID ...
      ZERO_APP_ID: commonEnv.ZERO_APP_ID,
    },
  },
  // after the view-syncer is deployed.
  {dependsOn: viewSyncer},
);
```

See the [SST Deployment Guide](deployment#guide-multi-node-on-sstaws) for more details.

## Rules

Each operation on a policy has a _ruleset_ containing zero or more _rules_.

A rule is just a TypeScript function that receives the logged in user's `AuthData` and generates a ZQL [where expression](reading-data#compound-filters). At least one rule in a ruleset must return a row for the operation to be allowed.

### Select

You can limit the data a user can read by specifying a `select` ruleset.

Select permissions act like filters. If a user does not have permission to read a row, it will be filtered out of the result set. It will not generate an error.

For example, imagine a select permission that restricts reads to only issues created by the user:

```ts
definePermissions<AuthData, Schema>(schema, () => {
  const allowIfIssueCreator = (
    authData: AuthData,
    {cmp}: ExpressionBuilder<Schema, 'issue'>,
  ) => cmp('creatorID', authData.sub);

  return {
    issue: {
      row: {
        select: [allowIfIssueCreator],
      },
    },
  } satisfies PermissionsConfig<AuthData, Schema>;
});
```

If the issue table has two rows, one created by the user and one by someone else, the user will only see the row they created in any queries.

<Note type="warning" heading="Column permissions are not currently supported">
Select permission applies to every column. The recommended approach for now is to factor out private fields into a separate table, e.g. `user_private`. Column permissions are planned but currently not a high priority.
</Note>

## Permissions Based on Auth Data

You can use the [`cmpLit` helper](reading-data#comparing-literal-values) to define permissions based on a field of the `authData` parameter:

```ts
definePermissions<AuthData, Schema>(schema, () => {
  const allowIfAdmin = (
    authData: AuthData,
    {cmpLit}: ExpressionBuilder<Schema, 'issue'>,
  ) => cmpLit(authData.role, 'admin');

  return {
    issue: {
      row: {
        select: [allowIfAdmin],
      },
    },
  } satisfies PermissionsConfig<AuthData, Schema>;
});
```

## Debugging

See [Debugging Permissions](./debug/permissions).

## Examples

See [hello-zero](https://github.com/rocicorp/hello-zero/blob/main/src/schema.ts) for a simple example of read permissions.
