---
title: React
---

Zero has built-in support for React. Here's what basic usage looks like.

## Setup

Use the `ZeroProvider` component to setup Zero. It takes care of creating and destroying `Zero` instances reactively:

```tsx
import {useSession} from 'my-auth-provider';
import {ZeroProvider} from '@rocicorp/zero/react';
import {type Schema, schema} from './schema.ts';
import {type Mutators, createMutators} from './mutators.ts';

export function Root() {
  const session = useSession();
  const {userID, authToken: auth} = session;
  const server = import.meta.env.VITE_PUBLIC_SERVER;

  const mutators = useMemo(() => {
    return createMutators(auth);
  }, [auth]);

  return (
    // ZeroProvider will reactively create and destroy Zero instances
    // as needed when props change.
    <ZeroProvider {...{userID, auth, schema, mutators, server}}>
      <App />
    </ZeroProvider>
  );
}
```

You can also pass a `Zero` instance to the `ZeroProvider` if you want to control the lifecycle of the `Zero` instance yourself:

```tsx
// ZeroProvider just sets up the context, it doesn't manage
// the lifecycle of the Zero instance.
<ZeroProvider zero={zero}>
  <App />
</ZeroProvider>
```

## Usage

Use the `useZero` hook to get access to the current `Zero` instance, then `useQuery` to run queries:

```tsx
import {useQuery, useZero} from '@rocicorp/zero/react';
import {syncedQuery} from '@rocicorp/zero';
import {builder, type Schema} from './schema.ts';
import {type Mutators} from './mutators.ts';

export const getIssues = syncedQuery(
  'issues',
  z.tuple([z.string().optional()]),
  (creatorID: string|undefined) => {
    let q = builder.issue
      .related('creator')
      .related('labels')
      .limit(100);

    if (creatorID) {
      q = q.where('creatorID', '=', creatorID);
    }
    return q;
  }
);

function IssueList() {
  const z = useZero<Schema, Mutators>();
  const userID = selectedUserID();
  const [issues, issuesDetail] = useQuery(getIssues(userID));

  return (
    <>
      <div>
        {issuesDetail.type === 'complete' ? 'Complete' : 'Partial'}
        results
      </div>
      <div>
        {issues.map(issue => (
          <IssueRow issue={issue} />
        ))}
      </div>
    </>
  );
}
```

## Suspense

The `useSuspenseQuery` hook is exactly like `useQuery`, except it support React Suspense.

```tsx
const [issues, issuesDetail] = useSuspenseQuery(issueQuery, {
  suspendUntil: 'complete', // 'partial' or 'complete'
});
```

Use the `suspendUntil` parameter to control how long to suspend for. The value `complete` suspends until authoritative results from the server are received. The `partial` value suspends until any non-empty data is received, or for a empty result that is `complete`.

## Examples

See [the sample directory](samples/) for more complete React examples.