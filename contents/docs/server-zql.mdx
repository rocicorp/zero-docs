---
title: ZQL on the Server
---

The Zero package includes utilities to run ZQL on the server directly against your upstream Postgres database.

This is useful for many reasons:

- It allows [mutators](/docs/mutators) to read data using ZQL to check permissions or invariants.
- You can use ZQL to implement standard REST endpoints, allowing you to share code with mutators.
- In the future ([but not yet implemented](#ssr)), this can support server-side rendering.

<Note type="warning" slug="schema-read">
  `ZQLDatabase` currently does a read of your postgres
  schema before every transaction. This is fine for most
  usages, but for high scale it may become a problem. [Let
  us know](https://bugs.rocicorp.dev/issue/3799) if you need
  a fix for this.
</Note>

## Creating a Database

To run ZQL on the database, you will create a `ZQLDatabase` instance. Zero ships with
several built-in factories for popular Postgres bindings libraries.

<CodeGroup
  labels={[
    {
      text: 'Drizzle',
      sync: {pgClient: 'drizzle'},
    },
    {
      text: 'node-postgres',
      sync: {pgClient: 'node-postgres'},
    },
    {
      text: 'postgres.js',
      sync: {pgClient: 'postgres-js'},
    },
  ]}
>

```ts
// app/api/mutate/db-provider.ts
import {zeroDrizzle} from '@rocicorp/zero/server/adapters/drizzle'
import {schema} from '../../zero/schema.ts'

// pass a drizzle client instance. for example:
export const drizzleClient = drizzle(pool, {
  schema: drizzleSchema
})
export const dbProvider = zeroDrizzle(schema, drizzleClient)

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface DefaultTypes {
    dbProvider: typeof dbProvider
  }
}
```

```ts
// app/api/mutate/db-provider.ts
import {zeroNodePg} from '@rocicorp/zero/server/adapters/pg'
import {Pool} from 'pg'
import {schema} from '../../zero/schema.ts'

const pool = new Pool({
  connectionString: process.env.ZERO_UPSTREAM_DB!
})
export const dbProvider = zeroNodePg(schema, pool)

// You can also pass a client instead of a pool:
//
// const client = new Client({
//   connectionString: process.env.ZERO_UPSTREAM_DB!
// })
// await client.connect()
// export const dbProvider = zeroNodePg(schema, client)

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface DefaultTypes {
    dbProvider: typeof dbProvider
  }
}
```

```ts
// app/api/mutate/db-provider.ts
import {zeroPostgresJS} from '@rocicorp/zero/server/adapters/postgresjs'
import postgres from 'postgres'
import {schema} from '../../zero/schema.ts'

const sql = postgres(process.env.ZERO_UPSTREAM_DB!)
export const dbProvider = zeroPostgresJS(schema, sql)

// Register the database provider for type safety
declare module '@rocicorp/zero' {
  interface DefaultTypes {
    dbProvider: typeof dbProvider
  }
}
```

</CodeGroup>

Within your mutators, you can access the underlying transaction via `tx.dbTransaction.wrappedTransaction`:

<CodeGroup
  labels={[
    {
      text: 'Drizzle',
      sync: {pgClient: 'drizzle'},
    },
    {
      text: 'node-postgres',
      sync: {pgClient: 'node-postgres'},
    },
    {
      text: 'postgres.js',
      sync: {pgClient: 'postgres-js'},
    },
  ]}
>

```ts
// mutators.ts
export const mutators = defineMutators({
  createUser: defineMutator(
    async ({tx, args: {id, name}}) => {
      if (tx.location === 'server') {
        await tx.dbTransaction.wrappedTransaction
          .insert(drizzleSchema.user)
          .values({id, name})
      }
    }
  )
})
```

```ts
// mutators.ts
export const mutators = defineMutators({
  createUser: defineMutator(
    async ({tx, args: {id, name}}) => {
      if (tx.location === 'server') {
        await tx.dbTransaction.wrappedTransaction.query(
          'insert into "user" (id, name) values ($1, $2) returning *',
          [id, name]
        )
      }
    }
  )
})
```

```ts
// mutators.ts
export const mutators = defineMutators({
  createUser: defineMutator(
    async ({tx, args: {id, name}}) => {
      if (tx.location === 'server') {
        await tx.dbTransaction.wrappedTransaction<
          {id: string; name: string}[]
        >`insert into "user" (id, name)
          values (${id}, ${name})
          returning *`
      }
    }
  )
})
```

</CodeGroup>

### Custom Database

To implement support for some other Postgres bindings library, you will implement the `DBConnection` interface.

See the implementations for the [existing adapters](https://github.com/rocicorp/mono/tree/main/packages/zero-server/src/adapters) for examples.

## Running ZQL

Once you have an instance of `ZQLDatabase`, use the `transaction()` method to run ZQL:

```ts
await db.transaction(async tx => {
  // await tx.mutate...
  // await tx.query...
  // await myMutator.fn({tx, ctx, args})
})
```

## SSR

Zero doesn't yet have the wiring setup in its bindings layers to really nicely support server-side rendering ([patches welcome though!](https://bugs.rocicorp.dev/issue/3491)).

For now, we don't recommend using Zero with SSR. Use your framework's recommended pattern to prevent SSR execution:

### Next.js

Add the `use client`
[directive](https://nextjs.org/docs/app/api-reference/directives/use-client).

### SolidStart

Wrap components that use Zero with the
[`clientOnly`](https://docs.solidjs.com/solid-start/reference/client/client-only)
higher-order component.

The standard `clientOnly` pattern uses dynamic imports, but note that this
approach (similar to [React's `lazy`](https://react.dev/reference/react/lazy))
works with any function returning a `Promise<{default: () => JSX.Element}>`. If
code splitting is unnecessary, you can skip the dynamic import.

### TanStack Start

Use [React's `lazy`](https://react.dev/reference/react/lazy) for dynamic
imports.
